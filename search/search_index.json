{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"contributing/","text":"Contributing \u00b6 Any contributions are very welcome. All bug reports, suggestions, ideas, comments are very useful for the integrity and continual development of flow-py-sdk . All of those can be reported as issues here . If you would like to contribute to the code, the best place to start is to run the examples locally. After that your environment will be set up for development. If you don't have anything specific in mind but still want to contribute make sure to check any open issues.","title":"Contributing"},{"location":"contributing/#contributing","text":"Any contributions are very welcome. All bug reports, suggestions, ideas, comments are very useful for the integrity and continual development of flow-py-sdk . All of those can be reported as issues here . If you would like to contribute to the code, the best place to start is to run the examples locally. After that your environment will be set up for development. If you don't have anything specific in mind but still want to contribute make sure to check any open issues.","title":"Contributing"},{"location":"examples/","text":"Examples \u00b6 Examples are meant to illustrate usage of flow-py-sdk . They can be found here Running The examples \u00b6 In case you want to debug the examples, or you just want to see them in action you can use the following steps. 1. Prerequisites \u00b6 flow-cli for starting the emulator ( step-by-step based installation instructions based on your OS ) a checkout of flow-py-sdk python 3.9 or higher poetry The first step is to install the dependencies of flow-py-sdk with poetry . To do this run the following command on the root of the checkout. poetry install After that start the flow emulator in ./example directory (because that is where the flow.json the emulator configuration is), using: flow emulator 2. Runing examples \u00b6 To run all the examples use: poetry run examples To run specific examples you can use the tag of the examples: poetry run examples [ExampleTag] e.g.: poetry run examples T.1. T.2. S.4.","title":"Running Examples"},{"location":"examples/#examples","text":"Examples are meant to illustrate usage of flow-py-sdk . They can be found here","title":"Examples"},{"location":"examples/#running-the-examples","text":"In case you want to debug the examples, or you just want to see them in action you can use the following steps.","title":"Running The examples"},{"location":"examples/#1-prerequisites","text":"flow-cli for starting the emulator ( step-by-step based installation instructions based on your OS ) a checkout of flow-py-sdk python 3.9 or higher poetry The first step is to install the dependencies of flow-py-sdk with poetry . To do this run the following command on the root of the checkout. poetry install After that start the flow emulator in ./example directory (because that is where the flow.json the emulator configuration is), using: flow emulator","title":"1. Prerequisites"},{"location":"examples/#2-runing-examples","text":"To run all the examples use: poetry run examples To run specific examples you can use the tag of the examples: poetry run examples [ExampleTag] e.g.: poetry run examples T.1. T.2. S.4.","title":"2. Runing examples"},{"location":"python_SDK_guide/","text":"Overview \u00b6 This reference documents all the methods available in the SDK, and explains in detail how these methods work. SDKs are open source, and you can use them according to the licence. The library client specifications can be found here: Getting Started \u00b6 Installing \u00b6 pip install flow-py-sdk or poetry add flow-py-sdk Importing the Library \u00b6 import flow_py_sdk Running examples \u00b6 See Running examples Connect \u00b6 The library uses gRPC to communicate with the access nodes and it must be configured with correct access node API URL. \ud83d\udcd6 Access API URLs can be found here . An error will be returned if the host is unreachable. The Access Nodes APIs hosted by DapperLabs are accessible at: Testnet access.devnet.nodes.onflow.org:9000 Mainnet access.mainnet.nodes.onflow.org:9000 Local Emulator 127.0.0.1:3569 Example: async with flow_client( host=\"127.0.0.1\", port=\"3569\" ) as flow_client: # do something with `flow_client` Querying the Flow Network \u00b6 After you have established a connection with an access node, you can query the Flow network to retrieve data about blocks, accounts, events and transactions. We will explore how to retrieve each of these entities in the sections below. Get Blocks \u00b6 Query the network for block by id, height or get the latest block. \ud83d\udcd6 Block ID is SHA3-256 hash of the entire block payload. This hash is stored as an ID field on any block response object (ie. response from GetLatestBlock ). \ud83d\udcd6 Block height expresses the height of the block on the chain. The latest block height increases by one for every valid block produced. Examples \u00b6 This example depicts ways to get the latest block as well as any other block by height or ID: You can use the GetLatestBlock method to fetch the latest sealed or unsealed block: async with flow_client( host=ctx.access_node_host, port=ctx.access_node_port ) as client: block = await client.get_latest_block( is_sealed=False # or is_sealed = True can be used for retrieving sealed block ) print(\"Block ID: {}\".format(block.id.hex())) print(\"Block height: {}\".format(block.height)) print(\"Block timestamp: [{}]\".format(block.timestamp)) You can use the get_block_by_i_d method to fetch the specific block with desired ID: async with flow_client( host=ctx.access_node_host, port=ctx.access_node_port ) as client: latest_block = await client.get_latest_block() block = await client.get_block_by_height( id=latest_block.id ) print(\"Block ID: {}\".format(block.id.hex())) print(\"Block height: {}\".format(block.height)) print(\"Block timestamp: [{}]\".format(block.timestamp)) Also get_block_by_height method can be used to fetch the specific block with desired height: async with flow_client( host=ctx.access_node_host, port=ctx.access_node_port ) as client: latest_block = await client.get_latest_block() block = await client.get_block_by_height( height=latest_block.height ) print(\"Block ID: {}\".format(block.id.hex())) print(\"Block height: {}\".format(block.height)) print(\"Block timestamp: [{}]\".format(block.timestamp)) Result output: Block ID: 8d08c88873d079d8f2d929853a647a8703597898532f3b7f79b0e3b0320d0bf7 Block height: 146 Block timestamp: [2021-10-28 14:12:41.172587+00:00] Block ID: 8d08c88873d079d8f2d929853a647a8703597898532f3b7f79b0e3b0320d0bf7 Block height: 146 Block timestamp: [2021-10-28 14:12:41.172587+00:00] Block ID: 8d08c88873d079d8f2d929853a647a8703597898532f3b7f79b0e3b0320d0bf7 Block height: 146 Block timestamp: [2021-10-28 14:12:41.172587+00:00] Get Account \u00b6 Retrieve any account from Flow network's latest block or from a specified block height. \ud83d\udcd6 Account address is a unique account identifier. Be mindful about the 0x prefix, you should use the prefix as a default representation but be careful and safely handle user inputs without the prefix. An account includes the following data: Address: the account address. Balance: balance of the account. Contracts: list of contracts deployed to the account. Keys: list of keys associated with the account. Examples \u00b6 Example depicts ways to get an account at the latest block and at a specific block height: Get an account using its address. async def run(self, ctx: Config): async with flow_client( host=ctx.access_node_host, port=ctx.access_node_port ) as client: account = await client.get_account( address=ctx.service_account_address.bytes ) print(\"Account Address: {}\".format(account.address.hex())) print(\"Account Balance: {}\".format(account.balance)) print(\"Account Contracts: {}\".format(len(account.contracts))) print(\"Account Keys: {}\".format(len(account.keys))) Get an account by address at the given block height. async def run(self, ctx: Config): async with flow_client( host=ctx.access_node_host, port=ctx.access_node_port ) as client: latest_block = await client.get_latest_block() _, _, _ = await random_account(client=client, ctx=ctx) account = await client.get_account_at_block_height( address=ctx.service_account_address.bytes, block_height=latest_block.height, ) print(\"Account Address: {}\".format(account.address.hex())) print(\"Account Balance: {}\".format(account.balance)) print(\"Account Contracts: {}\".format(len(account.contracts))) print(\"Account Keys: {}\".format(len(account.keys))) Get an account by address at the latest sealed block. async def run(self, ctx: Config): async with flow_client( host=ctx.access_node_host, port=ctx.access_node_port ) as client: _, _, _ = await random_account(client=client, ctx=ctx) account = await client.get_account_at_latest_block( address=ctx.service_account_address.bytes ) print(\"Account Address: {}\".format(account.address.hex())) print(\"Account Balance: {}\".format(account.balance)) print(\"Account Contracts: {}\".format(len(account.contracts))) print(\"Account Keys: {}\".format(len(account.keys))) Result output: Account Address: f8d6e0586b0a20c7 Account Balance: 999999999999700000 Account Balance: 2 Account Keys: 1 Account Address: f8d6e0586b0a20c7 Account Balance: 999999999999600000 Account Balance: 2 Account Keys: 1 Get Transactions \u00b6 Retrieve transactions from the network by providing a transaction ID. After a transaction has been submitted, you can also get the transaction result to check the status. \ud83d\udcd6 Transaction ID is a hash of the encoded transaction payload and can be calculated before submitting the transaction to the network. \u26a0\ufe0f The transaction ID provided must be from the current spork. \ud83d\udcd6 Transaction status represents the state of transaction in the blockchain. Status can change until is finalized. Status Final Description UNKNOWN \u274c The transaction has not yet been seen by the network PENDING \u274c The transaction has not yet been included in a block FINALIZED \u274c The transaction has been included in a block EXECUTED \u274c The transaction has been executed but the result has not yet been sealed SEALED \u2705 The transaction has been executed and the result is sealed in a block EXPIRED \u2705 The transaction reference block is outdated before being executed async def run(self, ctx: Config): async with flow_client( host=ctx.access_node_host, port=ctx.access_node_port ) as client: account_address, _, new_signer = await random_account( client=client, ctx=ctx ) latest_block = await client.get_latest_block() proposer = await client.get_account_at_latest_block( address=account_address.bytes ) transaction = Tx( code=\"\"\"transaction(){prepare(){log(\"OK\")}}\"\"\", reference_block_id=latest_block.id, payer=account_address, proposal_key=ProposalKey( key_address=account_address, key_id=0, key_sequence_number=proposer.keys[0].sequence_number, ), ).with_envelope_signature( account_address, 0, new_signer, ) response = await client.send_transaction(transaction=transaction.to_signed_grpc()) transaction_id = response.id transaction = await client.get_transaction(id=transaction_id) print(\"transaction ID: {}\".format(transaction_id.hex())) print(\"transaction payer: {}\".format(transaction.payer.hex())) print( \"transaction proposer: {}\".format( transaction.proposal_key.address.hex() ) ) print(\"transaction script: {}\".format(transaction.script.decode(\"utf-8\"))) Example output: transaction ID: 8f8adbfbe85cee39d3ee180a8c148b8ebc7bca8feae9f64a4c6f0c65e9db6663 transaction payer: 01cf0e2f2f715450 transaction proposer: 01cf0e2f2f715450 transaction script: transaction(){prepare(){log(\"OK\")}} Get Events \u00b6 Retrieve events by a given type in a specified block height range or through a list of block IDs. \ud83d\udcd6 Event type is a string that follow a standard format: A.{contract address}.{contract name}.{event name} Please read more about events in the documentation . The exception to this standard are core events, and you should read more about them in this document . \ud83d\udcd6 Block height range expresses the height of the start and end block in the chain. Examples \u00b6 Example depicts ways to get events within block range or by block IDs: This example shows how to retrieve events by name in the block height range Class. In this example, an account is created and then we try to get \"AccountCreated\" event. async def run(self, ctx: Config): async with flow_client( host=ctx.access_node_host, port=ctx.access_node_port ) as client: _, _, _ = await random_account(client=client, ctx=ctx) latest_block = await client.get_latest_block() await client.get_events_for_height_range( type=\"flow.AccountCreated\", start_height=latest_block.height - 1, end_height=latest_block.height, ) This example shows how to retrieve events by name in the block ids Function In this example, an account is created and then we try to get \"AccountCreated\" event. async def run(self, ctx: Config): async with flow_client( host=ctx.access_node_host, port=ctx.access_node_port ) as client: _, _, _ = await random_account(client=client, ctx=ctx) latest_block = await client.get_latest_block() await client.get_events_for_block_i_ds( type=\"flow.AccountCreated\", block_ids=[latest_block.id] ) print(\"event type: {}\".format(events[0].events[0].type)) print(\"event value: {}\".format(events[0].events[0].value)) print(\"event value: {}\".format(events[0].events[0].transaction_id.hex())) async def run(self, ctx: Config): async with flow_client( host=ctx.access_node_host, port=ctx.access_node_port ) as client: address, _, _ = await random_account( client=client, ctx=ctx, contracts={ \"EventDemo\": \"\"\" pub contract EventDemo { pub event Add(x: Int, y: Int, sum: Int) pub fun add(_ x: Int, _ y: Int) { let sum = x + y emit Add(x: x, y: y, sum: sum) } }\"\"\", }, ) block = await client.get_latest_block() proposer = await client.get_account_at_latest_block( address=ctx.service_account_address.bytes ) tx = Tx( code=f\"\"\" import EventDemo from {address.hex_with_prefix()} transaction() {{ prepare() {{ EventDemo.add(1, 6) }} }} \"\"\", reference_block_id=block.id, payer=ctx.service_account_address, proposal_key=ProposalKey( key_address=ctx.service_account_address, key_id=ctx.service_account_key_id, key_sequence_number=proposer.keys[ ctx.service_account_key_id ].sequence_number, ), ).with_envelope_signature( ctx.service_account_address, ctx.service_account_key_id, ctx.service_account_signer, ) result = await client.execute_transaction(tx) add_event = [ e.value for e in result.events if isinstance(e.value, cadence.Event) ][0] assert add_event.fields[2].as_type(cadence.Int).value == 7 print(\"event type: {}\".format(result.events[0].type)) print(\"event value: {}\".format(result.events[0].value)) print(\"event value: {}\".format(result.events[0].transaction_id.hex())) Example output: event type: flow.AccountCreated event value: flow.AccountCreated(address: 0xe9dd1081676bbc90) event value: 7762301429e09d9a981f99df24244b45ae3e9e5f084dde5f5167f1e73ce8e306 event type: A.0dbaa95c7691bc4f.EventDemo.Add event value: A.0dbaa95c7691bc4f.EventDemo.Add(x: 1, y: 6, sum: 7) event value: dfc8c1ea51279ddc74c16ed7644361dbe4828181d56497a4ebb18a6bbf0fd574 Get Collections \u00b6 Retrieve a batch of transactions that have been included in the same block, known as collections . Collections are used to improve consensus throughput by increasing the number of transactions per block and they act as a link between a block and a transaction. \ud83d\udcd6 Collection ID is SHA3-256 hash of the collection payload. Examples \u00b6 async def run(self, ctx: Config): async with flow_client( host=ctx.access_node_host, port=ctx.access_node_port ) as client: _, _, _ = await random_account(client=client, ctx=ctx) block = await client.get_latest_block(is_sealed=True) collection_id = block.collection_guarantees[0].collection_id collection = await client.get_collection_by_i_d(id=collection_id) print(\"ID: {}\".format(collection.id.hex())) print( \"Transactions: [{}]\".format( \", \".join(x.hex() for x in collection.transaction_ids) ) ) Example output: ID: afc6a69bf375f0eee80635091d50a1c4bb5479c1e6a04803e422a06614c45a7c Transactions: [d3a6b0cb53dfc72c38f365bb177a327c2bae8d4a6076a2909fc11d8f95510396] Execute Scripts \u00b6 Scripts allow you to write arbitrary non-mutating Cadence code on the Flow blockchain and return data. You can learn more about Cadence and scripts here , but we are now only interested in executing the script code and getting back the data. We can execute a script using the latest state of the Flow blockchain or we can choose to execute the script at a specific time in history defined by a block height or block ID. \ud83d\udcd6 Block ID is SHA3-256 hash of the entire block payload, but you can get that value from the block response properties. \ud83d\udcd6 Block height expresses the height of the block in the chain. // simple script pub fun main(a: Int): Int { return a + 10 } // complex script pub struct User { pub var balance: UFix64 pub var address: Address pub var name: String init(name: String, address: Address, balance: UFix64) { self.name = name self.address = address self.balance = balance } } pub fun main(name: String): User { return User( name: name, address: 0x1, balance: 10.0 ) } script can be a cadence function without any input: async def run(self, ctx: Config): script = Script( code=\"\"\" pub fun main(): Int { let a = 1 let b = 1 return a + b } \"\"\") async with flow_client( host=ctx.access_node_host, port=ctx.access_node_port ) as client: await client.execute_script( script=script # , block_id # , block_height ) or it can be a more complex function which has some input: async def run(self, ctx: Config): script = Script( code=\"\"\" pub struct User { pub var balance: UFix64 pub var address: Address pub var name: String init(name: String, address: Address, balance: UFix64) { self.name = name self.address = address self.balance = balance } } pub fun main(name: String): User { return User( name: name, address: 0x1, balance: 10.0 ) } \"\"\", arguments=[cadence.String(\"flow\")], ) async with flow_client( host=ctx.access_node_host, port=ctx.access_node_port ) as client: complex_script = await client.execute_script( script=script # , block_id # , block_height ) print(\"Name: {}\".format(complex_script.fields[2].value)) print(\"Address: {}\".format(complex_script.fields[1].bytes.hex())) print(\"Balance: {}\".format(complex_script.fields[0].value)) Name: flow Address: 0000000000000001 Balance: 1000000000 Mutate Flow Network \u00b6 Flow, like most blockchains, allows anybody to submit a transaction that mutates the shared global chain state. A transaction is an object that holds a payload, which describes the state mutation, and one or more authorizations that permit the transaction to mutate the state owned by specific accounts. Transaction data is composed and signed with help of the SDK. The signed payload of transaction then gets submitted to the access node API. If a transaction is invalid or the correct number of authorizing signatures are not provided, it gets rejected. Executing a transaction requires couple of steps: Building a transaction . Signing a transaction . Sending a transaction . Transactions \u00b6 A transaction is nothing more than a signed set of data that includes script code which are instructions on how to mutate the network state and properties that define and limit it's execution. All these properties are explained bellow. \ud83d\udcd6 Script field is the portion of the transaction that describes the state mutation logic. On Flow, transaction logic is written in Cadence . Here is an example transaction script: transaction(greeting: String) { execute { log(greeting.concat(\", World!\")) } } \ud83d\udcd6 Arguments . A transaction can accept zero or more arguments that are passed into the Cadence script. The arguments on the transaction must match the number and order declared in the Cadence script. Sample script from above accepts a single String argument. \ud83d\udcd6 Proposal key must be provided to act as a sequence number and prevent reply and other potential attacks. Each account key maintains a separate transaction sequence counter; the key that lends its sequence number to a transaction is called the proposal key. A proposal key contains three fields: Account address Key index Sequence number A transaction is only valid if its declared sequence number matches the current on-chain sequence number for that key. The sequence number increments by one after the transaction is executed. \ud83d\udcd6 Payer is the account that pays the fees for the transaction. A transaction must specify exactly one payer. The payer is only responsible for paying the network and gas fees; the transaction is not authorized to access resources or code stored in the payer account. \ud83d\udcd6 Authorizers are accounts that authorize a transaction to read and mutate their resources. A transaction can specify zero or more authorizers, depending on how many accounts the transaction needs to access. The number of authorizers on the transaction must match the number of AuthAccount parameters declared in the prepare statement of the Cadence script. Example transaction with multiple authorizers: transaction { prepare(authorizer1: AuthAccount, authorizer2: AuthAccount) { } } \ud83d\udcd6 Gas limit is the limit on the amount of computation a transaction requires, and it will abort if it exceeds its gas limit. Cadence uses metering to measure the number of operations per transaction. You can read more about it in the Cadence documentation . The gas limit depends on the complexity of the transaction script. Until dedicated gas estimation tooling exists, it's best to use the emulator to test complex transactions and determine a safe limit. \ud83d\udcd6 Reference block specifies an expiration window (measured in blocks) during which a transaction is considered valid by the network. A transaction will be rejected if it is submitted past its expiry block. Flow calculates transaction expiry using the reference block field on a transaction. A transaction expires after 600 blocks are committed on top of the reference block, which takes about 10 minutes at average Mainnet block rates. Build Transactions \u00b6 Building a transaction involves setting the required properties explained above and producing a transaction object. Here we define a simple transaction script that will be used to execute on the network and serve as a good learning example. transaction(greeting: String) { let guest: Address prepare(authorizer: AuthAccount) { self.guest = authorizer.address } execute { log(greeting.concat(\",\").concat(guest.toString())) } } transaction = Tx( code=\"\"\"transaction(){prepare(){log(\"OK\")}}\"\"\", reference_block_id=latest_block.id, payer=account_address, proposal_key=ProposalKey( key_address=account_address, key_id=0, key_sequence_number=proposer.keys[0].sequence_number, ) After you have successfully built a transaction the next step in the process is to sign it. Sign Transactions \u00b6 Flow introduces new concepts that allow for more flexibility when creating and signing transactions. Before trying the examples below, we recommend that you read through the transaction signature documentation . After you have successfully built a transaction the next step in the process is to sign it. Flow transactions have envelope and payload signatures, and you should learn about each in the signature documentation . Quick example of building a transaction: async def run(self, ctx: Config): async with flow_client( host=ctx.access_node_host, port=ctx.access_node_port ) as client: account_address, _, new_signer = await random_account( client=client, ctx=ctx ) latest_block = await client.get_latest_block() proposer = await client.get_account_at_latest_block( address=account_address.bytes ) transaction = Tx( code=\"\"\"transaction(){prepare(){log(\"OK\")}}\"\"\", reference_block_id=latest_block.id, payer=account_address, proposal_key=ProposalKey( key_address=account_address, key_id=0, key_sequence_number=proposer.keys[0].sequence_number, ), ) Signatures can be generated more securely using keys stored in a hardware device such as an HSM . The crypto.Signer interface is intended to be flexible enough to support a variety of signer implementations and is not limited to in-memory implementations. Simple signature example: async def run(self, ctx: Config): # First Step : Create a client to connect to the flow blockchain # flow_client function creates a client using the host and port async with flow_client( host=ctx.access_node_host, port=ctx.access_node_port ) as client: account_address, _, new_signer = await random_account( client=client, ctx=ctx ) latest_block = await client.get_latest_block() proposer = await client.get_account_at_latest_block( address=account_address.bytes ) transaction = Tx( code=\"\"\"transaction(){prepare(){log(\"OK\")}}\"\"\", reference_block_id=latest_block.id, payer=account_address, proposal_key=ProposalKey( key_address=account_address, key_id=0, key_sequence_number=proposer.keys[0].sequence_number, ), ).with_envelope_signature( account_address, 0, new_signer, ) Flow supports great flexibility when it comes to transaction signing, we can define multiple authorizers (multi-sig transactions) and have different payer account than proposer. We will explore advanced signing scenarios bellow. Single party, single signature \u00b6 Proposer, payer and authorizer are the same account ( 0x01 ). Only the envelope must be signed. Proposal key must have full signing weight. Account Key ID Weight 0x01 1 1.0 async def run(self, ctx: Config): address = Address.from_hex(\"0x01\") account = await client.get_account(address=address) # Assume you stored private key somewhere safe and restore it in private_key. signer = in_memory_signer.InMemorySigner(hash_algo=hash_algo, sign_algo=sign_algo, private_key_hex=private_key.to_string().hex()) async with flow_client( host=ctx.access_node_host, port=ctx.access_node_port ) as client: latest_block = await client.get_latest_block() tx = Tx( code=\"\"\" transaction { prepare(signer: AuthAccount) { log(signer.address) } } \"\"\", reference_block_id=latest_block.id, payer=account.address, proposal_key=ProposalKey( key_address=account.address, key_id=0, key_sequence_number=account.keys[ 0 ].sequence_number, ), ).add_authorizers([account.address]) .with_envelope_signature( account.address, 0, signer, ) Single party, multiple signatures \u00b6 Proposer, payer and authorizer are the same account ( 0x01 ). Only the envelope must be signed. Each key has weight 0.5, so two signatures are required. Account Key ID Weight 0x01 1 0.5 0x01 2 0.5 async def run(self, ctx: Config): address = Address.from_hex(\"0x01\") account = await client.get_account(address=address) # Assume you stored private key somewhere safe and restore it in private_key. signer1 = in_memory_signer.InMemorySigner(hash_algo=hash_algo, sign_algo=sign_algo, private_key_hex=private_key1.to_string().hex()) signer2 = in_memory_signer.InMemorySigner(hash_algo=hash_algo, sign_algo=sign_algo, private_key_hex=private_key2.to_string().hex()) async with flow_client( host=ctx.access_node_host, port=ctx.access_node_port ) as client: latest_block = await client.get_latest_block() tx = Tx( code=\"\"\" transaction { prepare(signer: AuthAccount) { log(signer.address) } } \"\"\", reference_block_id=latest_block.id, payer=account.address, proposal_key=ProposalKey( key_address=account.address, key_id=0, key_sequence_number=account.keys[ 0 ].sequence_number, ), ).add_authorizers([account.address]) .with_envelope_signature( account.address, 0, signer1, ).with_envelope_signature( account.address, 1, signer2, ) Multiple parties \u00b6 Proposer and authorizer are the same account ( 0x01 ). Payer is a separate account ( 0x02 ). Account 0x01 signs the payload. Account 0x02 signs the envelope. Account 0x02 must sign last since it is the payer. Account Key ID Weight 0x01 1 1.0 0x02 3 1.0 async def run(self, ctx: Config): # First Step : Create a client to connect to the flow blockchain # flow_client function creates a client using the host and port address1 = Address.from_hex(\"0x01\") address3 = Address.from_hex(\"0x02\") account = await client.get_account(address=address) # Assume you stored private key somewhere safe and restore it in private_key. signer1 = in_memory_signer.InMemorySigner(hash_algo=hash_algo, sign_algo=sign_algo, private_key_hex=private_key1.to_string().hex()) signer3 = in_memory_signer.InMemorySigner(hash_algo=hash_algo, sign_algo=sign_algo, private_key_hex=private_key3.to_string().hex()) async with flow_client( host=ctx.access_node_host, port=ctx.access_node_port ) as client: latest_block = await client.get_latest_block() tx = Tx( code=\"\"\" transaction { prepare(signer: AuthAccount) { log(signer.address) } } \"\"\", reference_block_id=latest_block.id, payer=account3.address, proposal_key=ProposalKey( key_address=account1.address, key_id=0, key_sequence_number=account.keys[ 0 ].sequence_number, ), ).add_authorizers([account1.address]) .with_payload_signature( account1.address, 0, signer1, ).with_envelope_signature( account3.address, 0, signer3, ) Multiple parties, two authorizers \u00b6 Proposer and authorizer are the same account ( 0x01 ). Payer is a separate account ( 0x02 ). Account 0x01 signs the payload. Account 0x02 signs the envelope. Account 0x02 must sign last since it is the payer. Account 0x02 is also an authorizer to show how to include two AuthAccounts into an transaction Account Key ID Weight 0x01 1 1.0 0x02 3 1.0 async def run(self, ctx: Config): # First Step : Create a client to connect to the flow blockchain # flow_client function creates a client using the host and port address1 = Address.from_hex(\"0x01\") address3 = Address.from_hex(\"0x02\") account = await client.get_account(address=address) # Assume you stored private key somewhere safe and restore it in private_key. signer1 = in_memory_signer.InMemorySigner(hash_algo=hash_algo, sign_algo=sign_algo, private_key_hex=private_key1.to_string().hex()) signer3 = in_memory_signer.InMemorySigner(hash_algo=hash_algo, sign_algo=sign_algo, private_key_hex=private_key3.to_string().hex()) async with flow_client( host=ctx.access_node_host, port=ctx.access_node_port ) as client: latest_block = await client.get_latest_block() tx = Tx( code=\"\"\" transaction { prepare(signer: AuthAccount) { log(signer.address) } } \"\"\", reference_block_id=latest_block.id, payer=account3.address, proposal_key=ProposalKey( key_address=account1.address, key_id=0, key_sequence_number=account.keys[ 0 ].sequence_number, ), ).add_authorizers([account1.address, account3.address]) .with_payload_signature( account1.address, 0, signer1, ).with_envelope_signature( account3.address, 0, signer3, ) Multiple parties, multiple signatures \u00b6 Proposer and authorizer are the same account ( 0x01 ). Payer is a separate account ( 0x02 ). Account 0x01 signs the payload. Account 0x02 signs the envelope. Account 0x02 must sign last since it is the payer. Both accounts must sign twice (once with each of their keys). Account Key ID Weight 0x01 1 0.5 0x01 2 0.5 0x02 3 0.5 0x02 4 0.5 async def run(self, ctx: Config): # First Step : Create a client to connect to the flow blockchain # flow_client function creates a client using the host and port address1 = Address.from_hex(\"0x01\") address3 = Address.from_hex(\"0x02\") account = await client.get_account(address=address) # Assume you stored private key somewhere safe and restore it in private_key. signer1 = in_memory_signer.InMemorySigner(hash_algo=hash_algo, sign_algo=sign_algo, private_key_hex=private_key1.to_string().hex()) signer2 = in_memory_signer.InMemorySigner(hash_algo=hash_algo, sign_algo=sign_algo, private_key_hex=private_key2.to_string().hex()) signer3 = in_memory_signer.InMemorySigner(hash_algo=hash_algo, sign_algo=sign_algo, private_key_hex=private_key3.to_string().hex()) signer4 = in_memory_signer.InMemorySigner(hash_algo=hash_algo, sign_algo=sign_algo, private_key_hex=private_key4.to_string().hex()) async with flow_client( host=ctx.access_node_host, port=ctx.access_node_port ) as client: latest_block = await client.get_latest_block() tx = Tx( code=\"\"\" transaction { prepare(signer: AuthAccount) { log(signer.address) } } \"\"\", reference_block_id=latest_block.id, payer=account2.address, proposal_key=ProposalKey( key_address=account1.address, key_id=0, key_sequence_number=account.keys[ 0 ].sequence_number, ), ).add_authorizers([account1.address]) .with_payload_signature( account1.address, 0, signer1, ).with_payload_signature( account1.address, 1, signer2, ).with_envelope_signature( account3.address, 0, signer3, ).with_envelope_signature( account3.address, 1, signer4, ) Signing user messages \u00b6 Signing and verifying user messages can be done by using Signer.sign_user_message . Verifying that an account (via its owners keys) has been signed can be done with utils.verify_user_signature Short sample: async def run(self, ctx: Config): async with flow_client( host=ctx.access_node_host, port=ctx.access_node_port ) as client: # create account account_address, _, account_signer = await random_account( client=client, ctx=ctx, ) # the message to sign. Could include some extra information, like the reference block id or the address. message = b\"Hello World!\" # sign message signature = account_signer.sign_user_message(message) c_signature = utils.CompositeSignature( account_address.hex(), 0, signature.hex() ) # verify the signature is valid signature_is_valid = await utils.verify_user_signature( message=message, client=client, composite_signatures=[c_signature], ) assert signature_is_valid Send Transactions \u00b6 After a transaction has been built and signed , it can be sent to the Flow blockchain where it will be executed. If sending was successful you can then retrieve the transaction result . async def run(self, ctx: Config): async with flow_client( host=ctx.access_node_host, port=ctx.access_node_port ) as client: account_address, _, new_signer = await random_account( client=client, ctx=ctx ) latest_block = await client.get_latest_block() proposer = await client.get_account_at_latest_block( address=account_address.bytes ) transaction = Tx( code=\"\"\"transaction(){prepare(){log(\"OK\")}}\"\"\", reference_block_id=latest_block.id, payer=account_address, proposal_key=ProposalKey( key_address=account_address, key_id=0, key_sequence_number=proposer.keys[0].sequence_number, ), ).with_envelope_signature( account_address, 0, new_signer, ) response = await client.send_transaction(transaction=transaction.to_signed_grpc()) Create Accounts \u00b6 On Flow, account creation happens inside a transaction. Because the network allows for a many-to-many relationship between public keys and accounts, it's not possible to derive a new account address from a public key offline. The Flow VM uses a deterministic address generation algorithm to assigen account addresses on chain. You can find more details about address generation in the accounts & keys documentation . Public Key \u00b6 Flow uses ECDSA key pairs to control access to user accounts. Each key pair can be used in combination with the SHA2-256 or SHA3-256 hashing algorithms. \u26a0\ufe0f You'll need to authorize at least one public key to control your new account. Flow represents ECDSA public keys in raw form without additional metadata. Each key is a single byte slice containing a concatenation of its X and Y components in big-endian byte form. A Flow account can contain zero (not possible to control) or more public keys, referred to as account keys. Read more about accounts in the documentation . An account key contains the following data: Raw public key (described above) Signature algorithm Hash algorithm Weight (integer between 0-1000) Account creation happens inside a transaction, which means that somebody must pay to submit that transaction to the network. We'll call this person the account creator. Make sure you have read sending a transaction section first. async def run(self, ctx: Config): async with flow_client( host=ctx.access_node_host, port=ctx.access_node_port ) as client: latest_block = await client.get_latest_block() proposer = await client.get_account_at_latest_block(address=ctx.service_account_address.bytes) tx = ( create_account_template( keys=[account_key], reference_block_id=latest_block.id, payer=ctx.service_account_address, proposal_key=ProposalKey( key_address=ctx.service_account_address, key_id=ctx.service_account_key_id, key_sequence_number=proposer.keys[ ctx.service_account_key_id ].sequence_number, ), ) .add_authorizers(ctx.service_account_address) .with_envelope_signature( ctx.service_account_address, 0, ctx.service_account_signer ) ) result = await client.execute_transaction(tx) print(\"new address event:\\n\") print(result.__dict__) print(\"\\nCreating account : successfully done...\") After the account creation transaction has been submitted you can retrieve the new account address by getting the transaction result . The new account address will be emitted in a system-level flow.AccountCreated event. await client.get_events_for_block_i_ds( type=\"flow.AccountCreated\", block_ids=[latest_block.id] ) Contracts \u00b6 Flow smart contracts are Codance scripts that run on Flow blockchain and can returns values. a contract can be add, update or remove from an account. A contracts contains the following fields: Name - Name of contract. source - Script of contract. Adding a contract to an account \u00b6 async def run(self, ctx: Config): # First Step : Create a client to connect to the flow blockchain # flow_client function creates a client using the host and port # A test Contract define for this example, you can modify it by your self contract = { \"Name\": \"TestOne\", \"source\": '''pub contract TestOne { pub fun add(a: Int, b: Int): Int { return a + b } }''' } contract_source_hex = bytes(contract[\"source\"], \"UTF-8\").hex() async with flow_client( host=ctx.access_node_host, port=ctx.access_node_port ) as client: account_address, account_key, new_signer = await random_account(client=client, ctx=ctx) latest_block = await client.get_latest_block() cadenceName = cadence.String(contract[\"Name\"]) cadenceCode = cadence.String(contract_source_hex) tx = ( Tx( code=addAccountContractTemplate, reference_block_id=latest_block.id, payer=account_address, ).add_arguments(cadenceName) .add_arguments(cadenceCode) .add_authorizers([account_address]) .with_envelope_signature( account_address, 0, new_signer, ) ) result = await client.execute_transaction(tx) Updating a contract of an account \u00b6 async def run(self, ctx: Config): # First Step : Create a client to connect to the flow blockchain # flow_client function creates a client using the host and port # A test Contract define for this example, you can modify it by your self contract = { \"Name\": \"TestOne\", \"source\": '''pub contract TestOne { pub fun add(a: Int, b: Int): Int { return a + b } }''' } contract_source_hex = bytes(contract[\"source\"], \"UTF-8\").hex() async with flow_client( host=ctx.access_node_host, port=ctx.access_node_port ) as client: account_address, account_key, new_signer = await random_account(client=client, ctx=ctx) latest_block = await client.get_latest_block() cadenceName = cadence.String(contract[\"Name\"]) cadenceCode = cadence.String(contract_source_hex) tx = ( Tx( code=addAccountContractTemplate, reference_block_id=latest_block.id, payer=account_address, ).add_arguments(cadenceName) .add_arguments(cadenceCode) .add_authorizers([account_address]) .with_envelope_signature( account_address, 0, new_signer, ) ) result = await client.execute_transaction(tx) latest_block = await client.get_latest_block() # Updated Contract contract = { \"Name\": \"TestOne\", \"source\": '''pub contract TestOne { pub fun add(a: Int, b: Int): Int { return a * b } }''' } contract_source_hex = bytes(contract[\"source\"], \"UTF-8\").hex() # Update account contract with a transaction tx = ( Tx( code=updateAccountContractTemplate, reference_block_id=latest_block.id, payer=account_address, ).add_arguments(contract[\"Name\"]) .add_arguments(contract_source_hex) .add_authorizers([account_address]) .with_envelope_signature( account_address, 0, new_signer, ) ) result = await client.execute_transaction(tx) Removing a contract from an account \u00b6 async def run(self, ctx: Config): # First Step : Create a client to connect to the flow blockchain # flow_client function creates a client using the host and port # A test Contract define for this example, you can modify it by your self contract = { \"Name\": \"TestOne\", \"source\": '''pub contract TestOne { pub fun add(a: Int, b: Int): Int { return a + b } }''' } contract_source_hex = bytes(contract[\"source\"], \"UTF-8\").hex() async with flow_client( host=ctx.access_node_host, port=ctx.access_node_port ) as client: account_address, account_key, new_signer = await random_account(client=client, ctx=ctx) latest_block = await client.get_latest_block() cadenceName = cadence.String(contract[\"Name\"]) cadenceCode = cadence.String(contract_source_hex) tx = ( Tx( code=addAccountContractTemplate, reference_block_id=latest_block.id, payer=account_address, ).add_arguments(cadenceName) .add_arguments(cadenceCode) .add_authorizers([account_address]) .with_envelope_signature( account_address, 0, new_signer, ) ) result = await client.execute_transaction(tx) # Delete the added contract from the account latest_block = await client.get_latest_block() tx = ( Tx( code=removeAccountContractTemplate, reference_block_id=latest_block.id, payer=account_address, ).add_arguments(cadenceName) .add_authorizers([account_address]) .with_envelope_signature( account_address, 0, new_signer, ) ) result = await client.execute_transaction(tx) Generate Keys \u00b6 Flow uses ECDSA signatures to control access to user accounts. Each key pair can be used in combination with the SHA2-256 or SHA3-256 hashing algorithms. Here's how to generate an ECDSA private key for the P-256 (secp256r1) curve. private_key = ecdsa.SigningKey.generate(curve=\"ECDSA_secp256k1\") public_key = sk.verifying_key.to_string() The example above uses an ECDSA key pair on the P-256 (secp256r1) elliptic curve. Flow also supports the secp256k1 curve used by Bitcoin and Ethereum. Read more about supported algorithms here .","title":"Overview"},{"location":"python_SDK_guide/#overview","text":"This reference documents all the methods available in the SDK, and explains in detail how these methods work. SDKs are open source, and you can use them according to the licence. The library client specifications can be found here:","title":"Overview"},{"location":"python_SDK_guide/#getting-started","text":"","title":"Getting Started"},{"location":"python_SDK_guide/#installing","text":"pip install flow-py-sdk or poetry add flow-py-sdk","title":"Installing"},{"location":"python_SDK_guide/#importing-the-library","text":"import flow_py_sdk","title":"Importing the Library"},{"location":"python_SDK_guide/#running-examples","text":"See Running examples","title":"Running examples"},{"location":"python_SDK_guide/#connect","text":"The library uses gRPC to communicate with the access nodes and it must be configured with correct access node API URL. \ud83d\udcd6 Access API URLs can be found here . An error will be returned if the host is unreachable. The Access Nodes APIs hosted by DapperLabs are accessible at: Testnet access.devnet.nodes.onflow.org:9000 Mainnet access.mainnet.nodes.onflow.org:9000 Local Emulator 127.0.0.1:3569 Example: async with flow_client( host=\"127.0.0.1\", port=\"3569\" ) as flow_client: # do something with `flow_client`","title":"Connect"},{"location":"python_SDK_guide/#querying-the-flow-network","text":"After you have established a connection with an access node, you can query the Flow network to retrieve data about blocks, accounts, events and transactions. We will explore how to retrieve each of these entities in the sections below.","title":"Querying the Flow Network"},{"location":"python_SDK_guide/#get-blocks","text":"Query the network for block by id, height or get the latest block. \ud83d\udcd6 Block ID is SHA3-256 hash of the entire block payload. This hash is stored as an ID field on any block response object (ie. response from GetLatestBlock ). \ud83d\udcd6 Block height expresses the height of the block on the chain. The latest block height increases by one for every valid block produced.","title":"Get Blocks"},{"location":"python_SDK_guide/#examples","text":"This example depicts ways to get the latest block as well as any other block by height or ID: You can use the GetLatestBlock method to fetch the latest sealed or unsealed block: async with flow_client( host=ctx.access_node_host, port=ctx.access_node_port ) as client: block = await client.get_latest_block( is_sealed=False # or is_sealed = True can be used for retrieving sealed block ) print(\"Block ID: {}\".format(block.id.hex())) print(\"Block height: {}\".format(block.height)) print(\"Block timestamp: [{}]\".format(block.timestamp)) You can use the get_block_by_i_d method to fetch the specific block with desired ID: async with flow_client( host=ctx.access_node_host, port=ctx.access_node_port ) as client: latest_block = await client.get_latest_block() block = await client.get_block_by_height( id=latest_block.id ) print(\"Block ID: {}\".format(block.id.hex())) print(\"Block height: {}\".format(block.height)) print(\"Block timestamp: [{}]\".format(block.timestamp)) Also get_block_by_height method can be used to fetch the specific block with desired height: async with flow_client( host=ctx.access_node_host, port=ctx.access_node_port ) as client: latest_block = await client.get_latest_block() block = await client.get_block_by_height( height=latest_block.height ) print(\"Block ID: {}\".format(block.id.hex())) print(\"Block height: {}\".format(block.height)) print(\"Block timestamp: [{}]\".format(block.timestamp)) Result output: Block ID: 8d08c88873d079d8f2d929853a647a8703597898532f3b7f79b0e3b0320d0bf7 Block height: 146 Block timestamp: [2021-10-28 14:12:41.172587+00:00] Block ID: 8d08c88873d079d8f2d929853a647a8703597898532f3b7f79b0e3b0320d0bf7 Block height: 146 Block timestamp: [2021-10-28 14:12:41.172587+00:00] Block ID: 8d08c88873d079d8f2d929853a647a8703597898532f3b7f79b0e3b0320d0bf7 Block height: 146 Block timestamp: [2021-10-28 14:12:41.172587+00:00]","title":"Examples"},{"location":"python_SDK_guide/#get-account","text":"Retrieve any account from Flow network's latest block or from a specified block height. \ud83d\udcd6 Account address is a unique account identifier. Be mindful about the 0x prefix, you should use the prefix as a default representation but be careful and safely handle user inputs without the prefix. An account includes the following data: Address: the account address. Balance: balance of the account. Contracts: list of contracts deployed to the account. Keys: list of keys associated with the account.","title":"Get Account"},{"location":"python_SDK_guide/#examples_1","text":"Example depicts ways to get an account at the latest block and at a specific block height: Get an account using its address. async def run(self, ctx: Config): async with flow_client( host=ctx.access_node_host, port=ctx.access_node_port ) as client: account = await client.get_account( address=ctx.service_account_address.bytes ) print(\"Account Address: {}\".format(account.address.hex())) print(\"Account Balance: {}\".format(account.balance)) print(\"Account Contracts: {}\".format(len(account.contracts))) print(\"Account Keys: {}\".format(len(account.keys))) Get an account by address at the given block height. async def run(self, ctx: Config): async with flow_client( host=ctx.access_node_host, port=ctx.access_node_port ) as client: latest_block = await client.get_latest_block() _, _, _ = await random_account(client=client, ctx=ctx) account = await client.get_account_at_block_height( address=ctx.service_account_address.bytes, block_height=latest_block.height, ) print(\"Account Address: {}\".format(account.address.hex())) print(\"Account Balance: {}\".format(account.balance)) print(\"Account Contracts: {}\".format(len(account.contracts))) print(\"Account Keys: {}\".format(len(account.keys))) Get an account by address at the latest sealed block. async def run(self, ctx: Config): async with flow_client( host=ctx.access_node_host, port=ctx.access_node_port ) as client: _, _, _ = await random_account(client=client, ctx=ctx) account = await client.get_account_at_latest_block( address=ctx.service_account_address.bytes ) print(\"Account Address: {}\".format(account.address.hex())) print(\"Account Balance: {}\".format(account.balance)) print(\"Account Contracts: {}\".format(len(account.contracts))) print(\"Account Keys: {}\".format(len(account.keys))) Result output: Account Address: f8d6e0586b0a20c7 Account Balance: 999999999999700000 Account Balance: 2 Account Keys: 1 Account Address: f8d6e0586b0a20c7 Account Balance: 999999999999600000 Account Balance: 2 Account Keys: 1","title":"Examples"},{"location":"python_SDK_guide/#get-transactions","text":"Retrieve transactions from the network by providing a transaction ID. After a transaction has been submitted, you can also get the transaction result to check the status. \ud83d\udcd6 Transaction ID is a hash of the encoded transaction payload and can be calculated before submitting the transaction to the network. \u26a0\ufe0f The transaction ID provided must be from the current spork. \ud83d\udcd6 Transaction status represents the state of transaction in the blockchain. Status can change until is finalized. Status Final Description UNKNOWN \u274c The transaction has not yet been seen by the network PENDING \u274c The transaction has not yet been included in a block FINALIZED \u274c The transaction has been included in a block EXECUTED \u274c The transaction has been executed but the result has not yet been sealed SEALED \u2705 The transaction has been executed and the result is sealed in a block EXPIRED \u2705 The transaction reference block is outdated before being executed async def run(self, ctx: Config): async with flow_client( host=ctx.access_node_host, port=ctx.access_node_port ) as client: account_address, _, new_signer = await random_account( client=client, ctx=ctx ) latest_block = await client.get_latest_block() proposer = await client.get_account_at_latest_block( address=account_address.bytes ) transaction = Tx( code=\"\"\"transaction(){prepare(){log(\"OK\")}}\"\"\", reference_block_id=latest_block.id, payer=account_address, proposal_key=ProposalKey( key_address=account_address, key_id=0, key_sequence_number=proposer.keys[0].sequence_number, ), ).with_envelope_signature( account_address, 0, new_signer, ) response = await client.send_transaction(transaction=transaction.to_signed_grpc()) transaction_id = response.id transaction = await client.get_transaction(id=transaction_id) print(\"transaction ID: {}\".format(transaction_id.hex())) print(\"transaction payer: {}\".format(transaction.payer.hex())) print( \"transaction proposer: {}\".format( transaction.proposal_key.address.hex() ) ) print(\"transaction script: {}\".format(transaction.script.decode(\"utf-8\"))) Example output: transaction ID: 8f8adbfbe85cee39d3ee180a8c148b8ebc7bca8feae9f64a4c6f0c65e9db6663 transaction payer: 01cf0e2f2f715450 transaction proposer: 01cf0e2f2f715450 transaction script: transaction(){prepare(){log(\"OK\")}}","title":"Get Transactions"},{"location":"python_SDK_guide/#get-events","text":"Retrieve events by a given type in a specified block height range or through a list of block IDs. \ud83d\udcd6 Event type is a string that follow a standard format: A.{contract address}.{contract name}.{event name} Please read more about events in the documentation . The exception to this standard are core events, and you should read more about them in this document . \ud83d\udcd6 Block height range expresses the height of the start and end block in the chain.","title":"Get Events"},{"location":"python_SDK_guide/#examples_2","text":"Example depicts ways to get events within block range or by block IDs: This example shows how to retrieve events by name in the block height range Class. In this example, an account is created and then we try to get \"AccountCreated\" event. async def run(self, ctx: Config): async with flow_client( host=ctx.access_node_host, port=ctx.access_node_port ) as client: _, _, _ = await random_account(client=client, ctx=ctx) latest_block = await client.get_latest_block() await client.get_events_for_height_range( type=\"flow.AccountCreated\", start_height=latest_block.height - 1, end_height=latest_block.height, ) This example shows how to retrieve events by name in the block ids Function In this example, an account is created and then we try to get \"AccountCreated\" event. async def run(self, ctx: Config): async with flow_client( host=ctx.access_node_host, port=ctx.access_node_port ) as client: _, _, _ = await random_account(client=client, ctx=ctx) latest_block = await client.get_latest_block() await client.get_events_for_block_i_ds( type=\"flow.AccountCreated\", block_ids=[latest_block.id] ) print(\"event type: {}\".format(events[0].events[0].type)) print(\"event value: {}\".format(events[0].events[0].value)) print(\"event value: {}\".format(events[0].events[0].transaction_id.hex())) async def run(self, ctx: Config): async with flow_client( host=ctx.access_node_host, port=ctx.access_node_port ) as client: address, _, _ = await random_account( client=client, ctx=ctx, contracts={ \"EventDemo\": \"\"\" pub contract EventDemo { pub event Add(x: Int, y: Int, sum: Int) pub fun add(_ x: Int, _ y: Int) { let sum = x + y emit Add(x: x, y: y, sum: sum) } }\"\"\", }, ) block = await client.get_latest_block() proposer = await client.get_account_at_latest_block( address=ctx.service_account_address.bytes ) tx = Tx( code=f\"\"\" import EventDemo from {address.hex_with_prefix()} transaction() {{ prepare() {{ EventDemo.add(1, 6) }} }} \"\"\", reference_block_id=block.id, payer=ctx.service_account_address, proposal_key=ProposalKey( key_address=ctx.service_account_address, key_id=ctx.service_account_key_id, key_sequence_number=proposer.keys[ ctx.service_account_key_id ].sequence_number, ), ).with_envelope_signature( ctx.service_account_address, ctx.service_account_key_id, ctx.service_account_signer, ) result = await client.execute_transaction(tx) add_event = [ e.value for e in result.events if isinstance(e.value, cadence.Event) ][0] assert add_event.fields[2].as_type(cadence.Int).value == 7 print(\"event type: {}\".format(result.events[0].type)) print(\"event value: {}\".format(result.events[0].value)) print(\"event value: {}\".format(result.events[0].transaction_id.hex())) Example output: event type: flow.AccountCreated event value: flow.AccountCreated(address: 0xe9dd1081676bbc90) event value: 7762301429e09d9a981f99df24244b45ae3e9e5f084dde5f5167f1e73ce8e306 event type: A.0dbaa95c7691bc4f.EventDemo.Add event value: A.0dbaa95c7691bc4f.EventDemo.Add(x: 1, y: 6, sum: 7) event value: dfc8c1ea51279ddc74c16ed7644361dbe4828181d56497a4ebb18a6bbf0fd574","title":"Examples"},{"location":"python_SDK_guide/#get-collections","text":"Retrieve a batch of transactions that have been included in the same block, known as collections . Collections are used to improve consensus throughput by increasing the number of transactions per block and they act as a link between a block and a transaction. \ud83d\udcd6 Collection ID is SHA3-256 hash of the collection payload.","title":"Get Collections"},{"location":"python_SDK_guide/#examples_3","text":"async def run(self, ctx: Config): async with flow_client( host=ctx.access_node_host, port=ctx.access_node_port ) as client: _, _, _ = await random_account(client=client, ctx=ctx) block = await client.get_latest_block(is_sealed=True) collection_id = block.collection_guarantees[0].collection_id collection = await client.get_collection_by_i_d(id=collection_id) print(\"ID: {}\".format(collection.id.hex())) print( \"Transactions: [{}]\".format( \", \".join(x.hex() for x in collection.transaction_ids) ) ) Example output: ID: afc6a69bf375f0eee80635091d50a1c4bb5479c1e6a04803e422a06614c45a7c Transactions: [d3a6b0cb53dfc72c38f365bb177a327c2bae8d4a6076a2909fc11d8f95510396]","title":"Examples"},{"location":"python_SDK_guide/#execute-scripts","text":"Scripts allow you to write arbitrary non-mutating Cadence code on the Flow blockchain and return data. You can learn more about Cadence and scripts here , but we are now only interested in executing the script code and getting back the data. We can execute a script using the latest state of the Flow blockchain or we can choose to execute the script at a specific time in history defined by a block height or block ID. \ud83d\udcd6 Block ID is SHA3-256 hash of the entire block payload, but you can get that value from the block response properties. \ud83d\udcd6 Block height expresses the height of the block in the chain. // simple script pub fun main(a: Int): Int { return a + 10 } // complex script pub struct User { pub var balance: UFix64 pub var address: Address pub var name: String init(name: String, address: Address, balance: UFix64) { self.name = name self.address = address self.balance = balance } } pub fun main(name: String): User { return User( name: name, address: 0x1, balance: 10.0 ) } script can be a cadence function without any input: async def run(self, ctx: Config): script = Script( code=\"\"\" pub fun main(): Int { let a = 1 let b = 1 return a + b } \"\"\") async with flow_client( host=ctx.access_node_host, port=ctx.access_node_port ) as client: await client.execute_script( script=script # , block_id # , block_height ) or it can be a more complex function which has some input: async def run(self, ctx: Config): script = Script( code=\"\"\" pub struct User { pub var balance: UFix64 pub var address: Address pub var name: String init(name: String, address: Address, balance: UFix64) { self.name = name self.address = address self.balance = balance } } pub fun main(name: String): User { return User( name: name, address: 0x1, balance: 10.0 ) } \"\"\", arguments=[cadence.String(\"flow\")], ) async with flow_client( host=ctx.access_node_host, port=ctx.access_node_port ) as client: complex_script = await client.execute_script( script=script # , block_id # , block_height ) print(\"Name: {}\".format(complex_script.fields[2].value)) print(\"Address: {}\".format(complex_script.fields[1].bytes.hex())) print(\"Balance: {}\".format(complex_script.fields[0].value)) Name: flow Address: 0000000000000001 Balance: 1000000000","title":"Execute Scripts"},{"location":"python_SDK_guide/#mutate-flow-network","text":"Flow, like most blockchains, allows anybody to submit a transaction that mutates the shared global chain state. A transaction is an object that holds a payload, which describes the state mutation, and one or more authorizations that permit the transaction to mutate the state owned by specific accounts. Transaction data is composed and signed with help of the SDK. The signed payload of transaction then gets submitted to the access node API. If a transaction is invalid or the correct number of authorizing signatures are not provided, it gets rejected. Executing a transaction requires couple of steps: Building a transaction . Signing a transaction . Sending a transaction .","title":"Mutate Flow Network"},{"location":"python_SDK_guide/#transactions","text":"A transaction is nothing more than a signed set of data that includes script code which are instructions on how to mutate the network state and properties that define and limit it's execution. All these properties are explained bellow. \ud83d\udcd6 Script field is the portion of the transaction that describes the state mutation logic. On Flow, transaction logic is written in Cadence . Here is an example transaction script: transaction(greeting: String) { execute { log(greeting.concat(\", World!\")) } } \ud83d\udcd6 Arguments . A transaction can accept zero or more arguments that are passed into the Cadence script. The arguments on the transaction must match the number and order declared in the Cadence script. Sample script from above accepts a single String argument. \ud83d\udcd6 Proposal key must be provided to act as a sequence number and prevent reply and other potential attacks. Each account key maintains a separate transaction sequence counter; the key that lends its sequence number to a transaction is called the proposal key. A proposal key contains three fields: Account address Key index Sequence number A transaction is only valid if its declared sequence number matches the current on-chain sequence number for that key. The sequence number increments by one after the transaction is executed. \ud83d\udcd6 Payer is the account that pays the fees for the transaction. A transaction must specify exactly one payer. The payer is only responsible for paying the network and gas fees; the transaction is not authorized to access resources or code stored in the payer account. \ud83d\udcd6 Authorizers are accounts that authorize a transaction to read and mutate their resources. A transaction can specify zero or more authorizers, depending on how many accounts the transaction needs to access. The number of authorizers on the transaction must match the number of AuthAccount parameters declared in the prepare statement of the Cadence script. Example transaction with multiple authorizers: transaction { prepare(authorizer1: AuthAccount, authorizer2: AuthAccount) { } } \ud83d\udcd6 Gas limit is the limit on the amount of computation a transaction requires, and it will abort if it exceeds its gas limit. Cadence uses metering to measure the number of operations per transaction. You can read more about it in the Cadence documentation . The gas limit depends on the complexity of the transaction script. Until dedicated gas estimation tooling exists, it's best to use the emulator to test complex transactions and determine a safe limit. \ud83d\udcd6 Reference block specifies an expiration window (measured in blocks) during which a transaction is considered valid by the network. A transaction will be rejected if it is submitted past its expiry block. Flow calculates transaction expiry using the reference block field on a transaction. A transaction expires after 600 blocks are committed on top of the reference block, which takes about 10 minutes at average Mainnet block rates.","title":"Transactions"},{"location":"python_SDK_guide/#build-transactions","text":"Building a transaction involves setting the required properties explained above and producing a transaction object. Here we define a simple transaction script that will be used to execute on the network and serve as a good learning example. transaction(greeting: String) { let guest: Address prepare(authorizer: AuthAccount) { self.guest = authorizer.address } execute { log(greeting.concat(\",\").concat(guest.toString())) } } transaction = Tx( code=\"\"\"transaction(){prepare(){log(\"OK\")}}\"\"\", reference_block_id=latest_block.id, payer=account_address, proposal_key=ProposalKey( key_address=account_address, key_id=0, key_sequence_number=proposer.keys[0].sequence_number, ) After you have successfully built a transaction the next step in the process is to sign it.","title":"Build Transactions"},{"location":"python_SDK_guide/#sign-transactions","text":"Flow introduces new concepts that allow for more flexibility when creating and signing transactions. Before trying the examples below, we recommend that you read through the transaction signature documentation . After you have successfully built a transaction the next step in the process is to sign it. Flow transactions have envelope and payload signatures, and you should learn about each in the signature documentation . Quick example of building a transaction: async def run(self, ctx: Config): async with flow_client( host=ctx.access_node_host, port=ctx.access_node_port ) as client: account_address, _, new_signer = await random_account( client=client, ctx=ctx ) latest_block = await client.get_latest_block() proposer = await client.get_account_at_latest_block( address=account_address.bytes ) transaction = Tx( code=\"\"\"transaction(){prepare(){log(\"OK\")}}\"\"\", reference_block_id=latest_block.id, payer=account_address, proposal_key=ProposalKey( key_address=account_address, key_id=0, key_sequence_number=proposer.keys[0].sequence_number, ), ) Signatures can be generated more securely using keys stored in a hardware device such as an HSM . The crypto.Signer interface is intended to be flexible enough to support a variety of signer implementations and is not limited to in-memory implementations. Simple signature example: async def run(self, ctx: Config): # First Step : Create a client to connect to the flow blockchain # flow_client function creates a client using the host and port async with flow_client( host=ctx.access_node_host, port=ctx.access_node_port ) as client: account_address, _, new_signer = await random_account( client=client, ctx=ctx ) latest_block = await client.get_latest_block() proposer = await client.get_account_at_latest_block( address=account_address.bytes ) transaction = Tx( code=\"\"\"transaction(){prepare(){log(\"OK\")}}\"\"\", reference_block_id=latest_block.id, payer=account_address, proposal_key=ProposalKey( key_address=account_address, key_id=0, key_sequence_number=proposer.keys[0].sequence_number, ), ).with_envelope_signature( account_address, 0, new_signer, ) Flow supports great flexibility when it comes to transaction signing, we can define multiple authorizers (multi-sig transactions) and have different payer account than proposer. We will explore advanced signing scenarios bellow.","title":"Sign Transactions"},{"location":"python_SDK_guide/#single-party-single-signature","text":"Proposer, payer and authorizer are the same account ( 0x01 ). Only the envelope must be signed. Proposal key must have full signing weight. Account Key ID Weight 0x01 1 1.0 async def run(self, ctx: Config): address = Address.from_hex(\"0x01\") account = await client.get_account(address=address) # Assume you stored private key somewhere safe and restore it in private_key. signer = in_memory_signer.InMemorySigner(hash_algo=hash_algo, sign_algo=sign_algo, private_key_hex=private_key.to_string().hex()) async with flow_client( host=ctx.access_node_host, port=ctx.access_node_port ) as client: latest_block = await client.get_latest_block() tx = Tx( code=\"\"\" transaction { prepare(signer: AuthAccount) { log(signer.address) } } \"\"\", reference_block_id=latest_block.id, payer=account.address, proposal_key=ProposalKey( key_address=account.address, key_id=0, key_sequence_number=account.keys[ 0 ].sequence_number, ), ).add_authorizers([account.address]) .with_envelope_signature( account.address, 0, signer, )","title":"Single party, single signature"},{"location":"python_SDK_guide/#single-party-multiple-signatures","text":"Proposer, payer and authorizer are the same account ( 0x01 ). Only the envelope must be signed. Each key has weight 0.5, so two signatures are required. Account Key ID Weight 0x01 1 0.5 0x01 2 0.5 async def run(self, ctx: Config): address = Address.from_hex(\"0x01\") account = await client.get_account(address=address) # Assume you stored private key somewhere safe and restore it in private_key. signer1 = in_memory_signer.InMemorySigner(hash_algo=hash_algo, sign_algo=sign_algo, private_key_hex=private_key1.to_string().hex()) signer2 = in_memory_signer.InMemorySigner(hash_algo=hash_algo, sign_algo=sign_algo, private_key_hex=private_key2.to_string().hex()) async with flow_client( host=ctx.access_node_host, port=ctx.access_node_port ) as client: latest_block = await client.get_latest_block() tx = Tx( code=\"\"\" transaction { prepare(signer: AuthAccount) { log(signer.address) } } \"\"\", reference_block_id=latest_block.id, payer=account.address, proposal_key=ProposalKey( key_address=account.address, key_id=0, key_sequence_number=account.keys[ 0 ].sequence_number, ), ).add_authorizers([account.address]) .with_envelope_signature( account.address, 0, signer1, ).with_envelope_signature( account.address, 1, signer2, )","title":"Single party, multiple signatures"},{"location":"python_SDK_guide/#multiple-parties","text":"Proposer and authorizer are the same account ( 0x01 ). Payer is a separate account ( 0x02 ). Account 0x01 signs the payload. Account 0x02 signs the envelope. Account 0x02 must sign last since it is the payer. Account Key ID Weight 0x01 1 1.0 0x02 3 1.0 async def run(self, ctx: Config): # First Step : Create a client to connect to the flow blockchain # flow_client function creates a client using the host and port address1 = Address.from_hex(\"0x01\") address3 = Address.from_hex(\"0x02\") account = await client.get_account(address=address) # Assume you stored private key somewhere safe and restore it in private_key. signer1 = in_memory_signer.InMemorySigner(hash_algo=hash_algo, sign_algo=sign_algo, private_key_hex=private_key1.to_string().hex()) signer3 = in_memory_signer.InMemorySigner(hash_algo=hash_algo, sign_algo=sign_algo, private_key_hex=private_key3.to_string().hex()) async with flow_client( host=ctx.access_node_host, port=ctx.access_node_port ) as client: latest_block = await client.get_latest_block() tx = Tx( code=\"\"\" transaction { prepare(signer: AuthAccount) { log(signer.address) } } \"\"\", reference_block_id=latest_block.id, payer=account3.address, proposal_key=ProposalKey( key_address=account1.address, key_id=0, key_sequence_number=account.keys[ 0 ].sequence_number, ), ).add_authorizers([account1.address]) .with_payload_signature( account1.address, 0, signer1, ).with_envelope_signature( account3.address, 0, signer3, )","title":"Multiple parties"},{"location":"python_SDK_guide/#multiple-parties-two-authorizers","text":"Proposer and authorizer are the same account ( 0x01 ). Payer is a separate account ( 0x02 ). Account 0x01 signs the payload. Account 0x02 signs the envelope. Account 0x02 must sign last since it is the payer. Account 0x02 is also an authorizer to show how to include two AuthAccounts into an transaction Account Key ID Weight 0x01 1 1.0 0x02 3 1.0 async def run(self, ctx: Config): # First Step : Create a client to connect to the flow blockchain # flow_client function creates a client using the host and port address1 = Address.from_hex(\"0x01\") address3 = Address.from_hex(\"0x02\") account = await client.get_account(address=address) # Assume you stored private key somewhere safe and restore it in private_key. signer1 = in_memory_signer.InMemorySigner(hash_algo=hash_algo, sign_algo=sign_algo, private_key_hex=private_key1.to_string().hex()) signer3 = in_memory_signer.InMemorySigner(hash_algo=hash_algo, sign_algo=sign_algo, private_key_hex=private_key3.to_string().hex()) async with flow_client( host=ctx.access_node_host, port=ctx.access_node_port ) as client: latest_block = await client.get_latest_block() tx = Tx( code=\"\"\" transaction { prepare(signer: AuthAccount) { log(signer.address) } } \"\"\", reference_block_id=latest_block.id, payer=account3.address, proposal_key=ProposalKey( key_address=account1.address, key_id=0, key_sequence_number=account.keys[ 0 ].sequence_number, ), ).add_authorizers([account1.address, account3.address]) .with_payload_signature( account1.address, 0, signer1, ).with_envelope_signature( account3.address, 0, signer3, )","title":"Multiple parties, two authorizers"},{"location":"python_SDK_guide/#multiple-parties-multiple-signatures","text":"Proposer and authorizer are the same account ( 0x01 ). Payer is a separate account ( 0x02 ). Account 0x01 signs the payload. Account 0x02 signs the envelope. Account 0x02 must sign last since it is the payer. Both accounts must sign twice (once with each of their keys). Account Key ID Weight 0x01 1 0.5 0x01 2 0.5 0x02 3 0.5 0x02 4 0.5 async def run(self, ctx: Config): # First Step : Create a client to connect to the flow blockchain # flow_client function creates a client using the host and port address1 = Address.from_hex(\"0x01\") address3 = Address.from_hex(\"0x02\") account = await client.get_account(address=address) # Assume you stored private key somewhere safe and restore it in private_key. signer1 = in_memory_signer.InMemorySigner(hash_algo=hash_algo, sign_algo=sign_algo, private_key_hex=private_key1.to_string().hex()) signer2 = in_memory_signer.InMemorySigner(hash_algo=hash_algo, sign_algo=sign_algo, private_key_hex=private_key2.to_string().hex()) signer3 = in_memory_signer.InMemorySigner(hash_algo=hash_algo, sign_algo=sign_algo, private_key_hex=private_key3.to_string().hex()) signer4 = in_memory_signer.InMemorySigner(hash_algo=hash_algo, sign_algo=sign_algo, private_key_hex=private_key4.to_string().hex()) async with flow_client( host=ctx.access_node_host, port=ctx.access_node_port ) as client: latest_block = await client.get_latest_block() tx = Tx( code=\"\"\" transaction { prepare(signer: AuthAccount) { log(signer.address) } } \"\"\", reference_block_id=latest_block.id, payer=account2.address, proposal_key=ProposalKey( key_address=account1.address, key_id=0, key_sequence_number=account.keys[ 0 ].sequence_number, ), ).add_authorizers([account1.address]) .with_payload_signature( account1.address, 0, signer1, ).with_payload_signature( account1.address, 1, signer2, ).with_envelope_signature( account3.address, 0, signer3, ).with_envelope_signature( account3.address, 1, signer4, )","title":"Multiple parties, multiple signatures"},{"location":"python_SDK_guide/#signing-user-messages","text":"Signing and verifying user messages can be done by using Signer.sign_user_message . Verifying that an account (via its owners keys) has been signed can be done with utils.verify_user_signature Short sample: async def run(self, ctx: Config): async with flow_client( host=ctx.access_node_host, port=ctx.access_node_port ) as client: # create account account_address, _, account_signer = await random_account( client=client, ctx=ctx, ) # the message to sign. Could include some extra information, like the reference block id or the address. message = b\"Hello World!\" # sign message signature = account_signer.sign_user_message(message) c_signature = utils.CompositeSignature( account_address.hex(), 0, signature.hex() ) # verify the signature is valid signature_is_valid = await utils.verify_user_signature( message=message, client=client, composite_signatures=[c_signature], ) assert signature_is_valid","title":"Signing user messages"},{"location":"python_SDK_guide/#send-transactions","text":"After a transaction has been built and signed , it can be sent to the Flow blockchain where it will be executed. If sending was successful you can then retrieve the transaction result . async def run(self, ctx: Config): async with flow_client( host=ctx.access_node_host, port=ctx.access_node_port ) as client: account_address, _, new_signer = await random_account( client=client, ctx=ctx ) latest_block = await client.get_latest_block() proposer = await client.get_account_at_latest_block( address=account_address.bytes ) transaction = Tx( code=\"\"\"transaction(){prepare(){log(\"OK\")}}\"\"\", reference_block_id=latest_block.id, payer=account_address, proposal_key=ProposalKey( key_address=account_address, key_id=0, key_sequence_number=proposer.keys[0].sequence_number, ), ).with_envelope_signature( account_address, 0, new_signer, ) response = await client.send_transaction(transaction=transaction.to_signed_grpc())","title":"Send Transactions"},{"location":"python_SDK_guide/#create-accounts","text":"On Flow, account creation happens inside a transaction. Because the network allows for a many-to-many relationship between public keys and accounts, it's not possible to derive a new account address from a public key offline. The Flow VM uses a deterministic address generation algorithm to assigen account addresses on chain. You can find more details about address generation in the accounts & keys documentation .","title":"Create Accounts"},{"location":"python_SDK_guide/#public-key","text":"Flow uses ECDSA key pairs to control access to user accounts. Each key pair can be used in combination with the SHA2-256 or SHA3-256 hashing algorithms. \u26a0\ufe0f You'll need to authorize at least one public key to control your new account. Flow represents ECDSA public keys in raw form without additional metadata. Each key is a single byte slice containing a concatenation of its X and Y components in big-endian byte form. A Flow account can contain zero (not possible to control) or more public keys, referred to as account keys. Read more about accounts in the documentation . An account key contains the following data: Raw public key (described above) Signature algorithm Hash algorithm Weight (integer between 0-1000) Account creation happens inside a transaction, which means that somebody must pay to submit that transaction to the network. We'll call this person the account creator. Make sure you have read sending a transaction section first. async def run(self, ctx: Config): async with flow_client( host=ctx.access_node_host, port=ctx.access_node_port ) as client: latest_block = await client.get_latest_block() proposer = await client.get_account_at_latest_block(address=ctx.service_account_address.bytes) tx = ( create_account_template( keys=[account_key], reference_block_id=latest_block.id, payer=ctx.service_account_address, proposal_key=ProposalKey( key_address=ctx.service_account_address, key_id=ctx.service_account_key_id, key_sequence_number=proposer.keys[ ctx.service_account_key_id ].sequence_number, ), ) .add_authorizers(ctx.service_account_address) .with_envelope_signature( ctx.service_account_address, 0, ctx.service_account_signer ) ) result = await client.execute_transaction(tx) print(\"new address event:\\n\") print(result.__dict__) print(\"\\nCreating account : successfully done...\") After the account creation transaction has been submitted you can retrieve the new account address by getting the transaction result . The new account address will be emitted in a system-level flow.AccountCreated event. await client.get_events_for_block_i_ds( type=\"flow.AccountCreated\", block_ids=[latest_block.id] )","title":"Public Key"},{"location":"python_SDK_guide/#contracts","text":"Flow smart contracts are Codance scripts that run on Flow blockchain and can returns values. a contract can be add, update or remove from an account. A contracts contains the following fields: Name - Name of contract. source - Script of contract.","title":"Contracts"},{"location":"python_SDK_guide/#adding-a-contract-to-an-account","text":"async def run(self, ctx: Config): # First Step : Create a client to connect to the flow blockchain # flow_client function creates a client using the host and port # A test Contract define for this example, you can modify it by your self contract = { \"Name\": \"TestOne\", \"source\": '''pub contract TestOne { pub fun add(a: Int, b: Int): Int { return a + b } }''' } contract_source_hex = bytes(contract[\"source\"], \"UTF-8\").hex() async with flow_client( host=ctx.access_node_host, port=ctx.access_node_port ) as client: account_address, account_key, new_signer = await random_account(client=client, ctx=ctx) latest_block = await client.get_latest_block() cadenceName = cadence.String(contract[\"Name\"]) cadenceCode = cadence.String(contract_source_hex) tx = ( Tx( code=addAccountContractTemplate, reference_block_id=latest_block.id, payer=account_address, ).add_arguments(cadenceName) .add_arguments(cadenceCode) .add_authorizers([account_address]) .with_envelope_signature( account_address, 0, new_signer, ) ) result = await client.execute_transaction(tx)","title":"Adding a contract to an account"},{"location":"python_SDK_guide/#updating-a-contract-of-an-account","text":"async def run(self, ctx: Config): # First Step : Create a client to connect to the flow blockchain # flow_client function creates a client using the host and port # A test Contract define for this example, you can modify it by your self contract = { \"Name\": \"TestOne\", \"source\": '''pub contract TestOne { pub fun add(a: Int, b: Int): Int { return a + b } }''' } contract_source_hex = bytes(contract[\"source\"], \"UTF-8\").hex() async with flow_client( host=ctx.access_node_host, port=ctx.access_node_port ) as client: account_address, account_key, new_signer = await random_account(client=client, ctx=ctx) latest_block = await client.get_latest_block() cadenceName = cadence.String(contract[\"Name\"]) cadenceCode = cadence.String(contract_source_hex) tx = ( Tx( code=addAccountContractTemplate, reference_block_id=latest_block.id, payer=account_address, ).add_arguments(cadenceName) .add_arguments(cadenceCode) .add_authorizers([account_address]) .with_envelope_signature( account_address, 0, new_signer, ) ) result = await client.execute_transaction(tx) latest_block = await client.get_latest_block() # Updated Contract contract = { \"Name\": \"TestOne\", \"source\": '''pub contract TestOne { pub fun add(a: Int, b: Int): Int { return a * b } }''' } contract_source_hex = bytes(contract[\"source\"], \"UTF-8\").hex() # Update account contract with a transaction tx = ( Tx( code=updateAccountContractTemplate, reference_block_id=latest_block.id, payer=account_address, ).add_arguments(contract[\"Name\"]) .add_arguments(contract_source_hex) .add_authorizers([account_address]) .with_envelope_signature( account_address, 0, new_signer, ) ) result = await client.execute_transaction(tx)","title":"Updating a contract of an account"},{"location":"python_SDK_guide/#removing-a-contract-from-an-account","text":"async def run(self, ctx: Config): # First Step : Create a client to connect to the flow blockchain # flow_client function creates a client using the host and port # A test Contract define for this example, you can modify it by your self contract = { \"Name\": \"TestOne\", \"source\": '''pub contract TestOne { pub fun add(a: Int, b: Int): Int { return a + b } }''' } contract_source_hex = bytes(contract[\"source\"], \"UTF-8\").hex() async with flow_client( host=ctx.access_node_host, port=ctx.access_node_port ) as client: account_address, account_key, new_signer = await random_account(client=client, ctx=ctx) latest_block = await client.get_latest_block() cadenceName = cadence.String(contract[\"Name\"]) cadenceCode = cadence.String(contract_source_hex) tx = ( Tx( code=addAccountContractTemplate, reference_block_id=latest_block.id, payer=account_address, ).add_arguments(cadenceName) .add_arguments(cadenceCode) .add_authorizers([account_address]) .with_envelope_signature( account_address, 0, new_signer, ) ) result = await client.execute_transaction(tx) # Delete the added contract from the account latest_block = await client.get_latest_block() tx = ( Tx( code=removeAccountContractTemplate, reference_block_id=latest_block.id, payer=account_address, ).add_arguments(cadenceName) .add_authorizers([account_address]) .with_envelope_signature( account_address, 0, new_signer, ) ) result = await client.execute_transaction(tx)","title":"Removing a contract from an account"},{"location":"python_SDK_guide/#generate-keys","text":"Flow uses ECDSA signatures to control access to user accounts. Each key pair can be used in combination with the SHA2-256 or SHA3-256 hashing algorithms. Here's how to generate an ECDSA private key for the P-256 (secp256r1) curve. private_key = ecdsa.SigningKey.generate(curve=\"ECDSA_secp256k1\") public_key = sk.verifying_key.to_string() The example above uses an ECDSA key pair on the P-256 (secp256r1) elliptic curve. Flow also supports the secp256k1 curve used by Bitcoin and Ethereum. Read more about supported algorithms here .","title":"Generate Keys"},{"location":"roadmap/","text":"Roadmap \u00b6 See the issues open in the github milestones","title":"Roadmap"},{"location":"roadmap/#roadmap","text":"See the issues open in the github milestones","title":"Roadmap"},{"location":"api_docs/client/","text":"Client API Docs \u00b6 Create a flow client \u00b6 flow_client ( host : Optional [ str ] = None , port : Optional [ int ] = None , * , loop : Optional [ asyncio . events . AbstractEventLoop ] = None , path : Optional [ str ] = None , codec : Optional [ grpclib . encoding . base . CodecBase ] = None , status_details_codec : Optional [ grpclib . encoding . base . StatusDetailsCodecBase ] = None , ssl = None , config : Optional [ grpclib . config . Configuration ] = None , timeout : Optional [ float ] = None , deadline : Optional [ Deadline ] = None , metadata = None ) -> AccessAPI \u00b6 Source code in flow_py_sdk/client/client.py def flow_client ( host : Optional [ str ] = None , port : Optional [ int ] = None , * , loop : Optional [ asyncio . AbstractEventLoop ] = None , path : Optional [ str ] = None , codec : Optional [ CodecBase ] = None , status_details_codec : Optional [ StatusDetailsCodecBase ] = None , ssl = None , config : Optional [ Configuration ] = None , timeout : Optional [ float ] = None , deadline : Optional [ \"Deadline\" ] = None , metadata = None , ) -> AccessAPI : channel = Channel ( host = host , port = port , loop = loop , path = path , codec = codec , status_details_codec = status_details_codec , ssl = ssl , config = config , ) return AccessAPI ( channel = channel , timeout = timeout , deadline = deadline , metadata = metadata ) Query Blocks \u00b6 get_latest_block_header ( self , * , is_sealed : bool = False ) -> BlockHeader async \u00b6 Get the full payload of the latest sealed or unsealed block header. Parameters \u00b6 is_sealed : bool Determine the requested block header should be sealed or not. Returns \u00b6 entities.BlockHeader Return requested block header. Source code in flow_py_sdk/client/client.py async def get_latest_block_header ( self , * , is_sealed : bool = False ) -> entities . BlockHeader : \"\"\" Get the full payload of the latest sealed or unsealed block header. Parameters ---------- is_sealed : bool Determine the requested block header should be sealed or not. Returns ------- entities.BlockHeader Return requested block header. \"\"\" response = await super () . get_latest_block_header ( is_sealed = is_sealed ) return entities . BlockHeader . from_proto ( response . block ) get_block_header_by_i_d ( self , * , id : bytes = b '' ) -> BlockHeader async \u00b6 Get a block header using its ID. Parameters \u00b6 id : bytes ID of requested block header. Returns \u00b6 entities.BlockHeader Return requested block header. Source code in flow_py_sdk/client/client.py async def get_block_header_by_i_d ( self , * , id : bytes = b \"\" ) -> entities . BlockHeader : \"\"\" Get a block header using its ID. Parameters ---------- id : bytes ID of requested block header. Returns ------- entities.BlockHeader Return requested block header. \"\"\" response = await super () . get_block_header_by_i_d ( id = id ) return entities . BlockHeader . from_proto ( response . block ) get_block_header_by_height ( self , * , height : int = 0 ) -> BlockHeader async \u00b6 Get a block header using its height. Parameters \u00b6 id : bytes ID of requested block header. Returns \u00b6 entities.BlockHeader Return requested block header. Source code in flow_py_sdk/client/client.py async def get_block_header_by_height ( self , * , height : int = 0 ) -> entities . BlockHeader : \"\"\" Get a block header using its height. Parameters ---------- id : bytes ID of requested block header. Returns ------- entities.BlockHeader Return requested block header. \"\"\" response = await super () . get_block_header_by_height ( height = height ) return entities . BlockHeader . from_proto ( response . block ) get_latest_block ( self , * , is_sealed : bool = False ) -> Block async \u00b6 Get the full payload of the latest sealed or unsealed block. Parameters \u00b6 is_sealed : bool Determine the requested block should be sealed or not. Returns \u00b6 entities.Block Return requested block. Source code in flow_py_sdk/client/client.py async def get_latest_block ( self , * , is_sealed : bool = False ) -> entities . Block : \"\"\" Get the full payload of the latest sealed or unsealed block. Parameters ---------- is_sealed : bool Determine the requested block should be sealed or not. Returns ------- entities.Block Return requested block. \"\"\" response = await super ( AccessAPI , self ) . get_latest_block ( is_sealed = is_sealed ) return entities . Block . from_proto ( response . block ) get_block_by_i_d ( self , * , id : bytes = b '' ) -> Block async \u00b6 Get a block using its ID. Parameters \u00b6 id : bytes ID of requested block. Returns \u00b6 entities.Block Return requested block. Source code in flow_py_sdk/client/client.py async def get_block_by_i_d ( self , * , id : bytes = b \"\" ) -> entities . Block : \"\"\" Get a block using its ID. Parameters ---------- id : bytes ID of requested block. Returns ------- entities.Block Return requested block. \"\"\" response = await super () . get_block_by_i_d ( id = id ) return entities . Block . from_proto ( response . block ) get_block_by_height ( self , * , height : int = 0 ) -> Block async \u00b6 Get a block using its height. Parameters \u00b6 height : int Height of requested block. Returns \u00b6 entities.Block Return requested block. Source code in flow_py_sdk/client/client.py async def get_block_by_height ( self , * , height : int = 0 ) -> entities . Block : \"\"\" Get a block using its height. Parameters ---------- height : int Height of requested block. Returns ------- entities.Block Return requested block. \"\"\" response = await super () . get_block_by_height ( height = height ) return entities . Block . from_proto ( response . block ) Accounts \u00b6 get_account ( self , * , address : bytes = b '' ) -> Account async \u00b6 Get an account using its address. Parameters \u00b6 address : bytes Address of requested account. Returns \u00b6 entities.Account Return requested account. Source code in flow_py_sdk/client/client.py async def get_account ( self , * , address : bytes = b \"\" ) -> entities . Account : \"\"\" Get an account using its address. Parameters ---------- address : bytes Address of requested account. Returns ------- entities.Account Return requested account. \"\"\" response = await super () . get_account ( address = address ) return entities . Account . from_proto ( response . account ) get_account_at_latest_block ( self , * , address : bytes = b '' ) -> Account async \u00b6 Get an account by address at the latest sealed block. Parameters \u00b6 address : bytes Address of requested account. Returns \u00b6 entities.Account Return requested account. Source code in flow_py_sdk/client/client.py async def get_account_at_latest_block ( self , * , address : bytes = b \"\" ) -> entities . Account : \"\"\" Get an account by address at the latest sealed block. Parameters ---------- address : bytes Address of requested account. Returns ------- entities.Account Return requested account. \"\"\" response = await super () . get_account_at_latest_block ( address = address ) return entities . Account . from_proto ( response . account ) get_account_at_block_height ( self , * , address : bytes = b '' , block_height : int = 0 ) -> Account async \u00b6 Get an account by address at the given block height. Parameters \u00b6 address : bytes Address of requested account. block_height : int Desired block height. Returns \u00b6 entities.Account Return requested account. Source code in flow_py_sdk/client/client.py async def get_account_at_block_height ( self , * , address : bytes = b \"\" , block_height : int = 0 ) -> entities . Account : \"\"\" Get an account by address at the given block height. Parameters ---------- address : bytes Address of requested account. block_height : int Desired block height. Returns ------- entities.Account Return requested account. \"\"\" response = await super () . get_account_at_block_height ( address = address , block_height = block_height ) return entities . Account . from_proto ( response . account ) Transactions \u00b6 get_transaction_result ( self , * , id : bytes = b '' ) -> TransactionResultResponse async \u00b6 Get a transaction response. Parameters \u00b6 !!! id \"byte\" Id of requested transaction. Returns \u00b6 entities.TransactionResultResponse Returns id of block Source code in flow_py_sdk/client/client.py async def get_transaction_result ( self , * , id : bytes = b \"\" ) -> entities . TransactionResultResponse : \"\"\" Get a transaction response. Parameters ---------- id: byte Id of requested transaction. Returns ------- entities.TransactionResultResponse Returns id of block \"\"\" response = await super () . get_transaction_result ( id = id ) return entities . TransactionResultResponse . from_proto ( response ) get_transaction ( self , * , id : bytes = b '' ) -> Transaction async \u00b6 Get a transaction using its ID. Parameters \u00b6 ID : bytes ID of requested transaction. Returns \u00b6 entities.Transaction Return requested transaction. Source code in flow_py_sdk/client/client.py async def get_transaction ( self , * , id : bytes = b \"\" ) -> entities . Transaction : \"\"\" Get a transaction using its ID. Parameters ---------- ID : bytes ID of requested transaction. Returns ------- entities.Transaction Return requested transaction. \"\"\" response = await super () . get_transaction ( id = id ) return entities . Transaction . from_proto ( response . transaction ) execute_transaction ( self , tx : Tx , * , wait_for_seal = True , timeout : Annotated [ float , 'seconds' ] = 30.0 ) -> TransactionResultResponse async \u00b6 Submit a transaction to the network and wait to return its response. Parameters \u00b6 !!! tx \"entities.Transaction\" A transaction object contains parameters like script, arguments, proposal_key, reference_block_id ... !!! wait_for_seal \"bool\" Return response when the block is sealed. !!! timeout \"float\" Time the function should wait for response Returns \u00b6 entities.TransactionResultResponse Returns id of block Source code in flow_py_sdk/client/client.py async def execute_transaction ( self , tx : Tx , * , wait_for_seal = True , timeout : Annotated [ float , \"seconds\" ] = 30.0 ) -> entities . TransactionResultResponse : \"\"\" Submit a transaction to the network and wait to return its response. Parameters ---------- tx: entities.Transaction A transaction object contains parameters like script, arguments, proposal_key, reference_block_id ... wait_for_seal: bool Return response when the block is sealed. timeout: float Time the function should wait for response Returns ------- entities.TransactionResultResponse Returns id of block \"\"\" log . debug ( f \"Sending transaction\" ) result = await self . send_transaction ( transaction = tx . to_signed_grpc ()) log . info ( f \"Sent transaction { result . id . hex () } \" ) tx_result = await self . get_transaction_result ( id = result . id ) if tx_result . error_message : raise Exception ( tx_result . error_message ) # TODO wrap error if not wait_for_seal : return tx_result log . info ( f \"Waiting for transaction to seal\" ) end_time = time . monotonic () + timeout while ( TransactionStatus ( tx_result . status ) is not TransactionStatus . TransactionStatusSealed and time . monotonic () < end_time ): await asyncio . sleep ( 1 ) tx_result = await self . get_transaction_result ( id = result . id ) if ( TransactionStatus ( tx_result . status ) is not TransactionStatus . TransactionStatusSealed ): raise TimeoutError ( f \"Waiting for transaction { result . id . hex () } to seal\" ) if tx_result . error_message : raise Exception ( tx_result . error_message ) # TODO wrap error log . info ( f \"Got transaction seal\" ) return tx_result send_transaction ( self , * , transaction : Optional [ flow_py_sdk . client . entities . Transaction ] = None ) -> SendTransactionResponse async \u00b6 Submit a transaction to the network. Parameters \u00b6 !!! transaction \"Optional[entities.Transaction]\" A transaction object contains parameters like script, arguments, proposal_key, reference_block_id ... Returns \u00b6 entities.SendTransactionResponse Returns id of block Source code in flow_py_sdk/client/client.py async def send_transaction ( self , * , transaction : Optional [ entities . Transaction ] = None ) -> entities . SendTransactionResponse : \"\"\" Submit a transaction to the network. Parameters ---------- transaction: Optional[entities.Transaction] A transaction object contains parameters like script, arguments, proposal_key, reference_block_id ... Returns ------- entities.SendTransactionResponse Returns id of block \"\"\" response = await super () . send_transaction ( transaction = transaction ) return entities . SendTransactionResponse . from_proto ( response ) Events \u00b6 get_events_for_height_range ( self , * , type : str = '' , start_height : int = 0 , end_height : int = 0 ) -> list async \u00b6 Query on blocks in specific height. The script is executed on an execution node and the return value is encoded using the JSON-Cadence data interchange format. Parameters \u00b6 type : str Type of requested type. !!! start_height \"int\" Start of desired range. end_height : int End of desired range. Returns \u00b6 List[entities.EventsResponseResult] Return the event results that are grouped by block, with each group specifying a block ID, height and block timestamp. Source code in flow_py_sdk/client/client.py async def get_events_for_height_range ( self , * , type : str = \"\" , start_height : int = 0 , end_height : int = 0 ) -> list [ entities . EventsResponseResult ]: \"\"\" Query on blocks in specific height. The script is executed on an execution node and the return value is encoded using the JSON-Cadence data interchange format. Parameters ---------- type : str Type of requested type. start_height: int Start of desired range. end_height : int End of desired range. Returns ------- List[entities.EventsResponseResult] Return the event results that are grouped by block, with each group specifying a block ID, height and block timestamp. \"\"\" response = await super () . get_events_for_height_range ( type = type , start_height = start_height , end_height = end_height ) return [ entities . EventsResponseResult . from_proto ( er ) for er in response . results ] get_events_for_block_i_ds ( self , * , type : str = '' , block_ids : List [ bytes ] = []) -> list async \u00b6 Query on blocks with specific IDs. The script is executed on an execution node and the return value is encoded using the JSON-Cadence data interchange format. Parameters \u00b6 type : str Type of requested type. !!! block_ids \"List[bytes]\" List of desired blocks. Returns \u00b6 list[entities.EventsResponseResult] Return the event results that are grouped by block, with each group specifying a block ID, height and block timestamp. Source code in flow_py_sdk/client/client.py async def get_events_for_block_i_ds ( self , * , type : str = \"\" , block_ids : List [ bytes ] = [] ) -> list [ entities . EventsResponseResult ]: \"\"\" Query on blocks with specific IDs. The script is executed on an execution node and the return value is encoded using the JSON-Cadence data interchange format. Parameters ---------- type : str Type of requested type. block_ids: List[bytes] List of desired blocks. Returns ------- list[entities.EventsResponseResult] Return the event results that are grouped by block, with each group specifying a block ID, height and block timestamp. \"\"\" response = await super () . get_events_for_block_i_ds ( type = type , block_ids = block_ids ) return [ entities . EventsResponseResult . from_proto ( er ) for er in response . results ] Collections \u00b6 get_collection_by_i_d ( self , * , id : bytes = b '' ) -> Collection async \u00b6 Get a collection using its ID. Parameters \u00b6 ID : bytes ID of requested collection. Returns \u00b6 entities.Collection Return requested collection. Source code in flow_py_sdk/client/client.py async def get_collection_by_i_d ( self , * , id : bytes = b \"\" ) -> entities . Collection : \"\"\" Get a collection using its ID. Parameters ---------- ID : bytes ID of requested collection. Returns ------- entities.Collection Return requested collection. \"\"\" response = await super () . get_collection_by_i_d ( id = id ) return entities . Collection . from_proto ( response . collection ) Scripts \u00b6 execute_script_at_latest_block ( self , * , script : bytes = b '' , arguments : List [ bytes ] = []) -> bytes async \u00b6 Execute a read-only Cadence script against the latest sealed block. The script is executed on an execution node and the return value is encoded using the JSON-Cadence data interchange format. Parameters \u00b6 script : bytes Cadence script which is wanted to perform. argument : List[bytes] List of argument which is need for performing script. Returns \u00b6 bytes Return value is encoded using the JSON-Cadence data interchange format. Source code in flow_py_sdk/client/client.py async def execute_script_at_latest_block ( self , * , script : bytes = b \"\" , arguments : List [ bytes ] = [] ) -> bytes : \"\"\" Execute a read-only Cadence script against the latest sealed block. The script is executed on an execution node and the return value is encoded using the JSON-Cadence data interchange format. Parameters ---------- script : bytes Cadence script which is wanted to perform. argument : List[bytes] List of argument which is need for performing script. Returns ------- bytes Return value is encoded using the JSON-Cadence data interchange format. \"\"\" response = await super () . execute_script_at_latest_block ( script = script , arguments = arguments ) return response . value execute_script_at_block_i_d ( self , * , block_id : bytes = b '' , script : bytes = b '' , arguments : List [ bytes ] = []) -> bytes async \u00b6 Execute a read-only Cadence script against the desired block with specific ID. The script is executed on an execution node and the return value is encoded using the JSON-Cadence data interchange format. Parameters \u00b6 !!! block_id \"bytes\" ID of desired block. script : bytes Cadence script which is wanted to perform. argument : List[bytes] List of argument which is need for performing script. Returns \u00b6 bytes Return value is encoded using the JSON-Cadence data interchange format. Source code in flow_py_sdk/client/client.py async def execute_script_at_block_i_d ( self , * , block_id : bytes = b \"\" , script : bytes = b \"\" , arguments : List [ bytes ] = [] ) -> bytes : \"\"\" Execute a read-only Cadence script against the desired block with specific ID. The script is executed on an execution node and the return value is encoded using the JSON-Cadence data interchange format. Parameters ---------- block_id: bytes ID of desired block. script : bytes Cadence script which is wanted to perform. argument : List[bytes] List of argument which is need for performing script. Returns ------- bytes Return value is encoded using the JSON-Cadence data interchange format. \"\"\" response = await super () . execute_script_at_block_i_d ( block_id = block_id , script = script , arguments = arguments ) return response . value execute_script_at_block_height ( self , * , block_height : int = 0 , script : bytes = b '' , arguments : List [ bytes ] = []) -> bytes async \u00b6 Execute a read-only Cadence script against the desired block with specific height. The script is executed on an execution node and the return value is encoded using the JSON-Cadence data interchange format. Parameters \u00b6 !!! block_height \"int\" Height of desired block. script : bytes Cadence script which is wanted to perform. argument : List[bytes] List of argument which is need for performing script. Returns \u00b6 bytes Return value is encoded using the JSON-Cadence data interchange format. Source code in flow_py_sdk/client/client.py async def execute_script_at_block_height ( self , * , block_height : int = 0 , script : bytes = b \"\" , arguments : List [ bytes ] = [] ) -> bytes : \"\"\" Execute a read-only Cadence script against the desired block with specific height. The script is executed on an execution node and the return value is encoded using the JSON-Cadence data interchange format. Parameters ---------- block_height: int Height of desired block. script : bytes Cadence script which is wanted to perform. argument : List[bytes] List of argument which is need for performing script. Returns ------- bytes Return value is encoded using the JSON-Cadence data interchange format. \"\"\" response = await super () . execute_script_at_block_height ( block_height = block_height , script = script , arguments = arguments ) return response . value","title":"Client"},{"location":"api_docs/client/#client-api-docs","text":"","title":"Client API Docs"},{"location":"api_docs/client/#create-a-flow-client","text":"","title":"Create a flow client"},{"location":"api_docs/client/#flow_py_sdk.client.client.flow_client","text":"Source code in flow_py_sdk/client/client.py def flow_client ( host : Optional [ str ] = None , port : Optional [ int ] = None , * , loop : Optional [ asyncio . AbstractEventLoop ] = None , path : Optional [ str ] = None , codec : Optional [ CodecBase ] = None , status_details_codec : Optional [ StatusDetailsCodecBase ] = None , ssl = None , config : Optional [ Configuration ] = None , timeout : Optional [ float ] = None , deadline : Optional [ \"Deadline\" ] = None , metadata = None , ) -> AccessAPI : channel = Channel ( host = host , port = port , loop = loop , path = path , codec = codec , status_details_codec = status_details_codec , ssl = ssl , config = config , ) return AccessAPI ( channel = channel , timeout = timeout , deadline = deadline , metadata = metadata )","title":"flow_client()"},{"location":"api_docs/client/#query-blocks","text":"","title":"Query Blocks"},{"location":"api_docs/client/#flow_py_sdk.client.client.AccessAPI.get_latest_block_header","text":"Get the full payload of the latest sealed or unsealed block header.","title":"get_latest_block_header()"},{"location":"api_docs/client/#flow_py_sdk.client.client.AccessAPI.get_latest_block_header--parameters","text":"is_sealed : bool Determine the requested block header should be sealed or not.","title":"Parameters"},{"location":"api_docs/client/#flow_py_sdk.client.client.AccessAPI.get_latest_block_header--returns","text":"entities.BlockHeader Return requested block header. Source code in flow_py_sdk/client/client.py async def get_latest_block_header ( self , * , is_sealed : bool = False ) -> entities . BlockHeader : \"\"\" Get the full payload of the latest sealed or unsealed block header. Parameters ---------- is_sealed : bool Determine the requested block header should be sealed or not. Returns ------- entities.BlockHeader Return requested block header. \"\"\" response = await super () . get_latest_block_header ( is_sealed = is_sealed ) return entities . BlockHeader . from_proto ( response . block )","title":"Returns"},{"location":"api_docs/client/#flow_py_sdk.client.client.AccessAPI.get_block_header_by_i_d","text":"Get a block header using its ID.","title":"get_block_header_by_i_d()"},{"location":"api_docs/client/#flow_py_sdk.client.client.AccessAPI.get_block_header_by_i_d--parameters","text":"id : bytes ID of requested block header.","title":"Parameters"},{"location":"api_docs/client/#flow_py_sdk.client.client.AccessAPI.get_block_header_by_i_d--returns","text":"entities.BlockHeader Return requested block header. Source code in flow_py_sdk/client/client.py async def get_block_header_by_i_d ( self , * , id : bytes = b \"\" ) -> entities . BlockHeader : \"\"\" Get a block header using its ID. Parameters ---------- id : bytes ID of requested block header. Returns ------- entities.BlockHeader Return requested block header. \"\"\" response = await super () . get_block_header_by_i_d ( id = id ) return entities . BlockHeader . from_proto ( response . block )","title":"Returns"},{"location":"api_docs/client/#flow_py_sdk.client.client.AccessAPI.get_block_header_by_height","text":"Get a block header using its height.","title":"get_block_header_by_height()"},{"location":"api_docs/client/#flow_py_sdk.client.client.AccessAPI.get_block_header_by_height--parameters","text":"id : bytes ID of requested block header.","title":"Parameters"},{"location":"api_docs/client/#flow_py_sdk.client.client.AccessAPI.get_block_header_by_height--returns","text":"entities.BlockHeader Return requested block header. Source code in flow_py_sdk/client/client.py async def get_block_header_by_height ( self , * , height : int = 0 ) -> entities . BlockHeader : \"\"\" Get a block header using its height. Parameters ---------- id : bytes ID of requested block header. Returns ------- entities.BlockHeader Return requested block header. \"\"\" response = await super () . get_block_header_by_height ( height = height ) return entities . BlockHeader . from_proto ( response . block )","title":"Returns"},{"location":"api_docs/client/#flow_py_sdk.client.client.AccessAPI.get_latest_block","text":"Get the full payload of the latest sealed or unsealed block.","title":"get_latest_block()"},{"location":"api_docs/client/#flow_py_sdk.client.client.AccessAPI.get_latest_block--parameters","text":"is_sealed : bool Determine the requested block should be sealed or not.","title":"Parameters"},{"location":"api_docs/client/#flow_py_sdk.client.client.AccessAPI.get_latest_block--returns","text":"entities.Block Return requested block. Source code in flow_py_sdk/client/client.py async def get_latest_block ( self , * , is_sealed : bool = False ) -> entities . Block : \"\"\" Get the full payload of the latest sealed or unsealed block. Parameters ---------- is_sealed : bool Determine the requested block should be sealed or not. Returns ------- entities.Block Return requested block. \"\"\" response = await super ( AccessAPI , self ) . get_latest_block ( is_sealed = is_sealed ) return entities . Block . from_proto ( response . block )","title":"Returns"},{"location":"api_docs/client/#flow_py_sdk.client.client.AccessAPI.get_block_by_i_d","text":"Get a block using its ID.","title":"get_block_by_i_d()"},{"location":"api_docs/client/#flow_py_sdk.client.client.AccessAPI.get_block_by_i_d--parameters","text":"id : bytes ID of requested block.","title":"Parameters"},{"location":"api_docs/client/#flow_py_sdk.client.client.AccessAPI.get_block_by_i_d--returns","text":"entities.Block Return requested block. Source code in flow_py_sdk/client/client.py async def get_block_by_i_d ( self , * , id : bytes = b \"\" ) -> entities . Block : \"\"\" Get a block using its ID. Parameters ---------- id : bytes ID of requested block. Returns ------- entities.Block Return requested block. \"\"\" response = await super () . get_block_by_i_d ( id = id ) return entities . Block . from_proto ( response . block )","title":"Returns"},{"location":"api_docs/client/#flow_py_sdk.client.client.AccessAPI.get_block_by_height","text":"Get a block using its height.","title":"get_block_by_height()"},{"location":"api_docs/client/#flow_py_sdk.client.client.AccessAPI.get_block_by_height--parameters","text":"height : int Height of requested block.","title":"Parameters"},{"location":"api_docs/client/#flow_py_sdk.client.client.AccessAPI.get_block_by_height--returns","text":"entities.Block Return requested block. Source code in flow_py_sdk/client/client.py async def get_block_by_height ( self , * , height : int = 0 ) -> entities . Block : \"\"\" Get a block using its height. Parameters ---------- height : int Height of requested block. Returns ------- entities.Block Return requested block. \"\"\" response = await super () . get_block_by_height ( height = height ) return entities . Block . from_proto ( response . block )","title":"Returns"},{"location":"api_docs/client/#accounts","text":"","title":"Accounts"},{"location":"api_docs/client/#flow_py_sdk.client.client.AccessAPI.get_account","text":"Get an account using its address.","title":"get_account()"},{"location":"api_docs/client/#flow_py_sdk.client.client.AccessAPI.get_account--parameters","text":"address : bytes Address of requested account.","title":"Parameters"},{"location":"api_docs/client/#flow_py_sdk.client.client.AccessAPI.get_account--returns","text":"entities.Account Return requested account. Source code in flow_py_sdk/client/client.py async def get_account ( self , * , address : bytes = b \"\" ) -> entities . Account : \"\"\" Get an account using its address. Parameters ---------- address : bytes Address of requested account. Returns ------- entities.Account Return requested account. \"\"\" response = await super () . get_account ( address = address ) return entities . Account . from_proto ( response . account )","title":"Returns"},{"location":"api_docs/client/#flow_py_sdk.client.client.AccessAPI.get_account_at_latest_block","text":"Get an account by address at the latest sealed block.","title":"get_account_at_latest_block()"},{"location":"api_docs/client/#flow_py_sdk.client.client.AccessAPI.get_account_at_latest_block--parameters","text":"address : bytes Address of requested account.","title":"Parameters"},{"location":"api_docs/client/#flow_py_sdk.client.client.AccessAPI.get_account_at_latest_block--returns","text":"entities.Account Return requested account. Source code in flow_py_sdk/client/client.py async def get_account_at_latest_block ( self , * , address : bytes = b \"\" ) -> entities . Account : \"\"\" Get an account by address at the latest sealed block. Parameters ---------- address : bytes Address of requested account. Returns ------- entities.Account Return requested account. \"\"\" response = await super () . get_account_at_latest_block ( address = address ) return entities . Account . from_proto ( response . account )","title":"Returns"},{"location":"api_docs/client/#flow_py_sdk.client.client.AccessAPI.get_account_at_block_height","text":"Get an account by address at the given block height.","title":"get_account_at_block_height()"},{"location":"api_docs/client/#flow_py_sdk.client.client.AccessAPI.get_account_at_block_height--parameters","text":"address : bytes Address of requested account. block_height : int Desired block height.","title":"Parameters"},{"location":"api_docs/client/#flow_py_sdk.client.client.AccessAPI.get_account_at_block_height--returns","text":"entities.Account Return requested account. Source code in flow_py_sdk/client/client.py async def get_account_at_block_height ( self , * , address : bytes = b \"\" , block_height : int = 0 ) -> entities . Account : \"\"\" Get an account by address at the given block height. Parameters ---------- address : bytes Address of requested account. block_height : int Desired block height. Returns ------- entities.Account Return requested account. \"\"\" response = await super () . get_account_at_block_height ( address = address , block_height = block_height ) return entities . Account . from_proto ( response . account )","title":"Returns"},{"location":"api_docs/client/#transactions","text":"","title":"Transactions"},{"location":"api_docs/client/#flow_py_sdk.client.client.AccessAPI.get_transaction_result","text":"Get a transaction response.","title":"get_transaction_result()"},{"location":"api_docs/client/#flow_py_sdk.client.client.AccessAPI.get_transaction_result--parameters","text":"!!! id \"byte\" Id of requested transaction.","title":"Parameters"},{"location":"api_docs/client/#flow_py_sdk.client.client.AccessAPI.get_transaction_result--returns","text":"entities.TransactionResultResponse Returns id of block Source code in flow_py_sdk/client/client.py async def get_transaction_result ( self , * , id : bytes = b \"\" ) -> entities . TransactionResultResponse : \"\"\" Get a transaction response. Parameters ---------- id: byte Id of requested transaction. Returns ------- entities.TransactionResultResponse Returns id of block \"\"\" response = await super () . get_transaction_result ( id = id ) return entities . TransactionResultResponse . from_proto ( response )","title":"Returns"},{"location":"api_docs/client/#flow_py_sdk.client.client.AccessAPI.get_transaction","text":"Get a transaction using its ID.","title":"get_transaction()"},{"location":"api_docs/client/#flow_py_sdk.client.client.AccessAPI.get_transaction--parameters","text":"ID : bytes ID of requested transaction.","title":"Parameters"},{"location":"api_docs/client/#flow_py_sdk.client.client.AccessAPI.get_transaction--returns","text":"entities.Transaction Return requested transaction. Source code in flow_py_sdk/client/client.py async def get_transaction ( self , * , id : bytes = b \"\" ) -> entities . Transaction : \"\"\" Get a transaction using its ID. Parameters ---------- ID : bytes ID of requested transaction. Returns ------- entities.Transaction Return requested transaction. \"\"\" response = await super () . get_transaction ( id = id ) return entities . Transaction . from_proto ( response . transaction )","title":"Returns"},{"location":"api_docs/client/#flow_py_sdk.client.client.AccessAPI.execute_transaction","text":"Submit a transaction to the network and wait to return its response.","title":"execute_transaction()"},{"location":"api_docs/client/#flow_py_sdk.client.client.AccessAPI.execute_transaction--parameters","text":"!!! tx \"entities.Transaction\" A transaction object contains parameters like script, arguments, proposal_key, reference_block_id ... !!! wait_for_seal \"bool\" Return response when the block is sealed. !!! timeout \"float\" Time the function should wait for response","title":"Parameters"},{"location":"api_docs/client/#flow_py_sdk.client.client.AccessAPI.execute_transaction--returns","text":"entities.TransactionResultResponse Returns id of block Source code in flow_py_sdk/client/client.py async def execute_transaction ( self , tx : Tx , * , wait_for_seal = True , timeout : Annotated [ float , \"seconds\" ] = 30.0 ) -> entities . TransactionResultResponse : \"\"\" Submit a transaction to the network and wait to return its response. Parameters ---------- tx: entities.Transaction A transaction object contains parameters like script, arguments, proposal_key, reference_block_id ... wait_for_seal: bool Return response when the block is sealed. timeout: float Time the function should wait for response Returns ------- entities.TransactionResultResponse Returns id of block \"\"\" log . debug ( f \"Sending transaction\" ) result = await self . send_transaction ( transaction = tx . to_signed_grpc ()) log . info ( f \"Sent transaction { result . id . hex () } \" ) tx_result = await self . get_transaction_result ( id = result . id ) if tx_result . error_message : raise Exception ( tx_result . error_message ) # TODO wrap error if not wait_for_seal : return tx_result log . info ( f \"Waiting for transaction to seal\" ) end_time = time . monotonic () + timeout while ( TransactionStatus ( tx_result . status ) is not TransactionStatus . TransactionStatusSealed and time . monotonic () < end_time ): await asyncio . sleep ( 1 ) tx_result = await self . get_transaction_result ( id = result . id ) if ( TransactionStatus ( tx_result . status ) is not TransactionStatus . TransactionStatusSealed ): raise TimeoutError ( f \"Waiting for transaction { result . id . hex () } to seal\" ) if tx_result . error_message : raise Exception ( tx_result . error_message ) # TODO wrap error log . info ( f \"Got transaction seal\" ) return tx_result","title":"Returns"},{"location":"api_docs/client/#flow_py_sdk.client.client.AccessAPI.send_transaction","text":"Submit a transaction to the network.","title":"send_transaction()"},{"location":"api_docs/client/#flow_py_sdk.client.client.AccessAPI.send_transaction--parameters","text":"!!! transaction \"Optional[entities.Transaction]\" A transaction object contains parameters like script, arguments, proposal_key, reference_block_id ...","title":"Parameters"},{"location":"api_docs/client/#flow_py_sdk.client.client.AccessAPI.send_transaction--returns","text":"entities.SendTransactionResponse Returns id of block Source code in flow_py_sdk/client/client.py async def send_transaction ( self , * , transaction : Optional [ entities . Transaction ] = None ) -> entities . SendTransactionResponse : \"\"\" Submit a transaction to the network. Parameters ---------- transaction: Optional[entities.Transaction] A transaction object contains parameters like script, arguments, proposal_key, reference_block_id ... Returns ------- entities.SendTransactionResponse Returns id of block \"\"\" response = await super () . send_transaction ( transaction = transaction ) return entities . SendTransactionResponse . from_proto ( response )","title":"Returns"},{"location":"api_docs/client/#events","text":"","title":"Events"},{"location":"api_docs/client/#flow_py_sdk.client.client.AccessAPI.get_events_for_height_range","text":"Query on blocks in specific height. The script is executed on an execution node and the return value is encoded using the JSON-Cadence data interchange format.","title":"get_events_for_height_range()"},{"location":"api_docs/client/#flow_py_sdk.client.client.AccessAPI.get_events_for_height_range--parameters","text":"type : str Type of requested type. !!! start_height \"int\" Start of desired range. end_height : int End of desired range.","title":"Parameters"},{"location":"api_docs/client/#flow_py_sdk.client.client.AccessAPI.get_events_for_height_range--returns","text":"List[entities.EventsResponseResult] Return the event results that are grouped by block, with each group specifying a block ID, height and block timestamp. Source code in flow_py_sdk/client/client.py async def get_events_for_height_range ( self , * , type : str = \"\" , start_height : int = 0 , end_height : int = 0 ) -> list [ entities . EventsResponseResult ]: \"\"\" Query on blocks in specific height. The script is executed on an execution node and the return value is encoded using the JSON-Cadence data interchange format. Parameters ---------- type : str Type of requested type. start_height: int Start of desired range. end_height : int End of desired range. Returns ------- List[entities.EventsResponseResult] Return the event results that are grouped by block, with each group specifying a block ID, height and block timestamp. \"\"\" response = await super () . get_events_for_height_range ( type = type , start_height = start_height , end_height = end_height ) return [ entities . EventsResponseResult . from_proto ( er ) for er in response . results ]","title":"Returns"},{"location":"api_docs/client/#flow_py_sdk.client.client.AccessAPI.get_events_for_block_i_ds","text":"Query on blocks with specific IDs. The script is executed on an execution node and the return value is encoded using the JSON-Cadence data interchange format.","title":"get_events_for_block_i_ds()"},{"location":"api_docs/client/#flow_py_sdk.client.client.AccessAPI.get_events_for_block_i_ds--parameters","text":"type : str Type of requested type. !!! block_ids \"List[bytes]\" List of desired blocks.","title":"Parameters"},{"location":"api_docs/client/#flow_py_sdk.client.client.AccessAPI.get_events_for_block_i_ds--returns","text":"list[entities.EventsResponseResult] Return the event results that are grouped by block, with each group specifying a block ID, height and block timestamp. Source code in flow_py_sdk/client/client.py async def get_events_for_block_i_ds ( self , * , type : str = \"\" , block_ids : List [ bytes ] = [] ) -> list [ entities . EventsResponseResult ]: \"\"\" Query on blocks with specific IDs. The script is executed on an execution node and the return value is encoded using the JSON-Cadence data interchange format. Parameters ---------- type : str Type of requested type. block_ids: List[bytes] List of desired blocks. Returns ------- list[entities.EventsResponseResult] Return the event results that are grouped by block, with each group specifying a block ID, height and block timestamp. \"\"\" response = await super () . get_events_for_block_i_ds ( type = type , block_ids = block_ids ) return [ entities . EventsResponseResult . from_proto ( er ) for er in response . results ]","title":"Returns"},{"location":"api_docs/client/#collections","text":"","title":"Collections"},{"location":"api_docs/client/#flow_py_sdk.client.client.AccessAPI.get_collection_by_i_d","text":"Get a collection using its ID.","title":"get_collection_by_i_d()"},{"location":"api_docs/client/#flow_py_sdk.client.client.AccessAPI.get_collection_by_i_d--parameters","text":"ID : bytes ID of requested collection.","title":"Parameters"},{"location":"api_docs/client/#flow_py_sdk.client.client.AccessAPI.get_collection_by_i_d--returns","text":"entities.Collection Return requested collection. Source code in flow_py_sdk/client/client.py async def get_collection_by_i_d ( self , * , id : bytes = b \"\" ) -> entities . Collection : \"\"\" Get a collection using its ID. Parameters ---------- ID : bytes ID of requested collection. Returns ------- entities.Collection Return requested collection. \"\"\" response = await super () . get_collection_by_i_d ( id = id ) return entities . Collection . from_proto ( response . collection )","title":"Returns"},{"location":"api_docs/client/#scripts","text":"","title":"Scripts"},{"location":"api_docs/client/#flow_py_sdk.client.client.AccessAPI.execute_script_at_latest_block","text":"Execute a read-only Cadence script against the latest sealed block. The script is executed on an execution node and the return value is encoded using the JSON-Cadence data interchange format.","title":"execute_script_at_latest_block()"},{"location":"api_docs/client/#flow_py_sdk.client.client.AccessAPI.execute_script_at_latest_block--parameters","text":"script : bytes Cadence script which is wanted to perform. argument : List[bytes] List of argument which is need for performing script.","title":"Parameters"},{"location":"api_docs/client/#flow_py_sdk.client.client.AccessAPI.execute_script_at_latest_block--returns","text":"bytes Return value is encoded using the JSON-Cadence data interchange format. Source code in flow_py_sdk/client/client.py async def execute_script_at_latest_block ( self , * , script : bytes = b \"\" , arguments : List [ bytes ] = [] ) -> bytes : \"\"\" Execute a read-only Cadence script against the latest sealed block. The script is executed on an execution node and the return value is encoded using the JSON-Cadence data interchange format. Parameters ---------- script : bytes Cadence script which is wanted to perform. argument : List[bytes] List of argument which is need for performing script. Returns ------- bytes Return value is encoded using the JSON-Cadence data interchange format. \"\"\" response = await super () . execute_script_at_latest_block ( script = script , arguments = arguments ) return response . value","title":"Returns"},{"location":"api_docs/client/#flow_py_sdk.client.client.AccessAPI.execute_script_at_block_i_d","text":"Execute a read-only Cadence script against the desired block with specific ID. The script is executed on an execution node and the return value is encoded using the JSON-Cadence data interchange format.","title":"execute_script_at_block_i_d()"},{"location":"api_docs/client/#flow_py_sdk.client.client.AccessAPI.execute_script_at_block_i_d--parameters","text":"!!! block_id \"bytes\" ID of desired block. script : bytes Cadence script which is wanted to perform. argument : List[bytes] List of argument which is need for performing script.","title":"Parameters"},{"location":"api_docs/client/#flow_py_sdk.client.client.AccessAPI.execute_script_at_block_i_d--returns","text":"bytes Return value is encoded using the JSON-Cadence data interchange format. Source code in flow_py_sdk/client/client.py async def execute_script_at_block_i_d ( self , * , block_id : bytes = b \"\" , script : bytes = b \"\" , arguments : List [ bytes ] = [] ) -> bytes : \"\"\" Execute a read-only Cadence script against the desired block with specific ID. The script is executed on an execution node and the return value is encoded using the JSON-Cadence data interchange format. Parameters ---------- block_id: bytes ID of desired block. script : bytes Cadence script which is wanted to perform. argument : List[bytes] List of argument which is need for performing script. Returns ------- bytes Return value is encoded using the JSON-Cadence data interchange format. \"\"\" response = await super () . execute_script_at_block_i_d ( block_id = block_id , script = script , arguments = arguments ) return response . value","title":"Returns"},{"location":"api_docs/client/#flow_py_sdk.client.client.AccessAPI.execute_script_at_block_height","text":"Execute a read-only Cadence script against the desired block with specific height. The script is executed on an execution node and the return value is encoded using the JSON-Cadence data interchange format.","title":"execute_script_at_block_height()"},{"location":"api_docs/client/#flow_py_sdk.client.client.AccessAPI.execute_script_at_block_height--parameters","text":"!!! block_height \"int\" Height of desired block. script : bytes Cadence script which is wanted to perform. argument : List[bytes] List of argument which is need for performing script.","title":"Parameters"},{"location":"api_docs/client/#flow_py_sdk.client.client.AccessAPI.execute_script_at_block_height--returns","text":"bytes Return value is encoded using the JSON-Cadence data interchange format. Source code in flow_py_sdk/client/client.py async def execute_script_at_block_height ( self , * , block_height : int = 0 , script : bytes = b \"\" , arguments : List [ bytes ] = [] ) -> bytes : \"\"\" Execute a read-only Cadence script against the desired block with specific height. The script is executed on an execution node and the return value is encoded using the JSON-Cadence data interchange format. Parameters ---------- block_height: int Height of desired block. script : bytes Cadence script which is wanted to perform. argument : List[bytes] List of argument which is need for performing script. Returns ------- bytes Return value is encoded using the JSON-Cadence data interchange format. \"\"\" response = await super () . execute_script_at_block_height ( block_height = block_height , script = script , arguments = arguments ) return response . value","title":"Returns"},{"location":"api_docs/keys/","text":"Keys \u00b6 Generate new keys \u00b6 from_seed ( sign_algo : SignAlgo = < SignAlgo . ECDSA_P256 : 2 > , hash_algo : HashAlgo = < HashAlgo . SHA3_256 : 3 > , * , seed : str = None ) -> tuple [ AccountKey , in_memory_signer . InMemorySigner ] classmethod \u00b6 from_seed provide a way for user to create a public and private key for an account using, seed string. Parameters \u00b6 sign_algo : int Signature algorithm associate with account. hash_algo : str Hash algorithm associate with account. seed : str The seed associate with account. Returns \u00b6 AccountKey Return Account Key contain public and hash algorithm and signature algorithm. it also create a InMemorySigner, it can be use signing messages and transactions. Source code in flow_py_sdk/account_key.py @classmethod def from_seed ( cls , sign_algo : SignAlgo = SignAlgo . ECDSA_P256 , hash_algo : HashAlgo = HashAlgo . SHA3_256 , * , seed : str = None ) -> tuple [ AccountKey , in_memory_signer . InMemorySigner ]: \"\"\" from_seed provide a way for user to create a public and private key for an account using, seed string. Parameters ---------- sign_algo : int Signature algorithm associate with account. hash_algo : str Hash algorithm associate with account. seed : str The seed associate with account. Returns ------- AccountKey Return Account Key contain public and hash algorithm and signature algorithm. it also create a InMemorySigner, it can be use signing messages and transactions. \"\"\" # Generate private key using provided Seed. if seed == None : sk = SigningKey . generate () private_key = sk . to_string () else : secexp = randrange_from_seed__trytryagain ( seed , sign_algo . get_signing_curve () . order ) sk = SigningKey . from_secret_exponent ( secexp , curve = sign_algo . get_signing_curve () ) private_key = sk . to_string () # Extract public Key (verifying Key) of generated private key. vk = sk . get_verifying_key () public_key = vk . to_string () # Create Account Key. ak = AccountKey ( public_key = public_key , hash_algo = hash_algo , sign_algo = sign_algo ) # Save generated private key in in_memory_signer for further messages or transaction Signing. signer = in_memory_signer . InMemorySigner ( hash_algo = hash_algo , sign_algo = sign_algo , private_key_hex = private_key . hex () ) return ak , signer","title":"Keys"},{"location":"api_docs/keys/#keys","text":"","title":"Keys"},{"location":"api_docs/keys/#generate-new-keys","text":"","title":"Generate new keys"},{"location":"api_docs/keys/#flow_py_sdk.account_key.AccountKey.from_seed","text":"from_seed provide a way for user to create a public and private key for an account using, seed string.","title":"from_seed()"},{"location":"api_docs/keys/#flow_py_sdk.account_key.AccountKey.from_seed--parameters","text":"sign_algo : int Signature algorithm associate with account. hash_algo : str Hash algorithm associate with account. seed : str The seed associate with account.","title":"Parameters"},{"location":"api_docs/keys/#flow_py_sdk.account_key.AccountKey.from_seed--returns","text":"AccountKey Return Account Key contain public and hash algorithm and signature algorithm. it also create a InMemorySigner, it can be use signing messages and transactions. Source code in flow_py_sdk/account_key.py @classmethod def from_seed ( cls , sign_algo : SignAlgo = SignAlgo . ECDSA_P256 , hash_algo : HashAlgo = HashAlgo . SHA3_256 , * , seed : str = None ) -> tuple [ AccountKey , in_memory_signer . InMemorySigner ]: \"\"\" from_seed provide a way for user to create a public and private key for an account using, seed string. Parameters ---------- sign_algo : int Signature algorithm associate with account. hash_algo : str Hash algorithm associate with account. seed : str The seed associate with account. Returns ------- AccountKey Return Account Key contain public and hash algorithm and signature algorithm. it also create a InMemorySigner, it can be use signing messages and transactions. \"\"\" # Generate private key using provided Seed. if seed == None : sk = SigningKey . generate () private_key = sk . to_string () else : secexp = randrange_from_seed__trytryagain ( seed , sign_algo . get_signing_curve () . order ) sk = SigningKey . from_secret_exponent ( secexp , curve = sign_algo . get_signing_curve () ) private_key = sk . to_string () # Extract public Key (verifying Key) of generated private key. vk = sk . get_verifying_key () public_key = vk . to_string () # Create Account Key. ak = AccountKey ( public_key = public_key , hash_algo = hash_algo , sign_algo = sign_algo ) # Save generated private key in in_memory_signer for further messages or transaction Signing. signer = in_memory_signer . InMemorySigner ( hash_algo = hash_algo , sign_algo = sign_algo , private_key_hex = private_key . hex () ) return ak , signer","title":"Returns"},{"location":"api_docs/signer/","text":"Signer \u00b6 Signer Base Class \u00b6 Signer \u00b6 The Signer class This is an abstract base class that is used for signing transactions and messages. __init__ ( self ) -> None special \u00b6 Source code in flow_py_sdk/signer/signer.py def __init__ ( self ) -> None : super () . __init__ () sign ( self , message : bytes , tag : Optional [ bytes ] = None ) -> bytes \u00b6 The sign method signs a message with a tag and returns the signature Parameters \u00b6 message : bytes The message to sign. tag : str The tag to sign with. Returns \u00b6 bytes The signed message. Source code in flow_py_sdk/signer/signer.py @abstractmethod def sign ( self , message : bytes , tag : Optional [ bytes ] = None ) -> bytes : \"\"\"The sign method signs a message with a tag and returns the signature Parameters ---------- message : bytes The message to sign. tag : str The tag to sign with. Returns ------- bytes The signed message. \"\"\" pass sign_transaction ( self , message : bytes ) -> bytes \u00b6 The sign_user_message method signs a message with the transaction tag and returns the signature Used to sign user messages Parameters \u00b6 message : bytes The message to sign. Returns \u00b6 bytes The signed message. Source code in flow_py_sdk/signer/signer.py def sign_transaction ( self , message : bytes ) -> bytes : \"\"\"The sign_user_message method signs a message with the transaction tag and returns the signature Used to sign user messages Parameters ---------- message : bytes The message to sign. Returns ------- bytes The signed message. \"\"\" return self . sign ( message , TransactionDomainTag ) sign_user_message ( self , message : bytes ) -> bytes \u00b6 The sign_user_message method signs a message with the user tag and returns the signature Used to sign user messages Parameters \u00b6 message : int The message to sign. Returns \u00b6 bytes The signed message. Source code in flow_py_sdk/signer/signer.py def sign_user_message ( self , message : bytes ) -> bytes : \"\"\"The sign_user_message method signs a message with the user tag and returns the signature Used to sign user messages Parameters ---------- message : int The message to sign. Returns ------- bytes The signed message. \"\"\" return self . sign ( message , UserDomainTag ) In Memory signer Implementation \u00b6 InMemorySigner \u00b6 __init__ ( self , * , hash_algo : HashAlgo , sign_algo : SignAlgo , private_key_hex : str ) -> None special \u00b6 Source code in flow_py_sdk/signer/in_memory_signer.py def __init__ ( self , * , hash_algo : HashAlgo , sign_algo : SignAlgo , private_key_hex : str ) -> None : super () . __init__ () self . hash_algo = hash_algo self . key = ecdsa . SigningKey . from_string ( bytes . fromhex ( private_key_hex ), curve = sign_algo . get_signing_curve () ) self . verifier = InMemoryVerifier ( hash_algo = hash_algo , sign_algo = sign_algo , public_key_hex = self . key . get_verifying_key () . to_string () . hex (), ) sign ( self , message : bytes , tag : Optional [ bytes ] = None ) -> bytes \u00b6 The sign method signs a message with a tag and returns the signature Parameters \u00b6 message : bytes The message to sign. tag : str The tag to sign with. Returns \u00b6 bytes The signed message. Source code in flow_py_sdk/signer/in_memory_signer.py def sign ( self , message : bytes , tag : Optional [ bytes ] = None ) -> bytes : hash_ = self . _hash_message ( message , tag ) return self . key . sign_digest_deterministic ( hash_ ) verify ( self , signature : bytes , message : bytes , tag : bytes ) -> bool \u00b6 The verify method signs a message with a tag and returns the signature Parameters \u00b6 signature : bytes The signature to verify. message : bytes The message to verify. tag : str The tag to verify. Returns \u00b6 bool Is the signature valid. Source code in flow_py_sdk/signer/in_memory_signer.py def verify ( self , signature : bytes , message : bytes , tag : bytes ) -> bool : return self . verifier . verify ( signature , message , tag )","title":"Signer"},{"location":"api_docs/signer/#signer","text":"","title":"Signer"},{"location":"api_docs/signer/#signer-base-class","text":"","title":"Signer Base Class"},{"location":"api_docs/signer/#flow_py_sdk.signer.signer.Signer","text":"The Signer class This is an abstract base class that is used for signing transactions and messages.","title":"Signer"},{"location":"api_docs/signer/#flow_py_sdk.signer.signer.Signer.__init__","text":"Source code in flow_py_sdk/signer/signer.py def __init__ ( self ) -> None : super () . __init__ ()","title":"__init__()"},{"location":"api_docs/signer/#flow_py_sdk.signer.signer.Signer.sign","text":"The sign method signs a message with a tag and returns the signature","title":"sign()"},{"location":"api_docs/signer/#flow_py_sdk.signer.signer.Signer.sign--parameters","text":"message : bytes The message to sign. tag : str The tag to sign with.","title":"Parameters"},{"location":"api_docs/signer/#flow_py_sdk.signer.signer.Signer.sign--returns","text":"bytes The signed message. Source code in flow_py_sdk/signer/signer.py @abstractmethod def sign ( self , message : bytes , tag : Optional [ bytes ] = None ) -> bytes : \"\"\"The sign method signs a message with a tag and returns the signature Parameters ---------- message : bytes The message to sign. tag : str The tag to sign with. Returns ------- bytes The signed message. \"\"\" pass","title":"Returns"},{"location":"api_docs/signer/#flow_py_sdk.signer.signer.Signer.sign_transaction","text":"The sign_user_message method signs a message with the transaction tag and returns the signature Used to sign user messages","title":"sign_transaction()"},{"location":"api_docs/signer/#flow_py_sdk.signer.signer.Signer.sign_transaction--parameters","text":"message : bytes The message to sign.","title":"Parameters"},{"location":"api_docs/signer/#flow_py_sdk.signer.signer.Signer.sign_transaction--returns","text":"bytes The signed message. Source code in flow_py_sdk/signer/signer.py def sign_transaction ( self , message : bytes ) -> bytes : \"\"\"The sign_user_message method signs a message with the transaction tag and returns the signature Used to sign user messages Parameters ---------- message : bytes The message to sign. Returns ------- bytes The signed message. \"\"\" return self . sign ( message , TransactionDomainTag )","title":"Returns"},{"location":"api_docs/signer/#flow_py_sdk.signer.signer.Signer.sign_user_message","text":"The sign_user_message method signs a message with the user tag and returns the signature Used to sign user messages","title":"sign_user_message()"},{"location":"api_docs/signer/#flow_py_sdk.signer.signer.Signer.sign_user_message--parameters","text":"message : int The message to sign.","title":"Parameters"},{"location":"api_docs/signer/#flow_py_sdk.signer.signer.Signer.sign_user_message--returns","text":"bytes The signed message. Source code in flow_py_sdk/signer/signer.py def sign_user_message ( self , message : bytes ) -> bytes : \"\"\"The sign_user_message method signs a message with the user tag and returns the signature Used to sign user messages Parameters ---------- message : int The message to sign. Returns ------- bytes The signed message. \"\"\" return self . sign ( message , UserDomainTag )","title":"Returns"},{"location":"api_docs/signer/#in-memory-signer-implementation","text":"","title":"In Memory signer Implementation"},{"location":"api_docs/signer/#flow_py_sdk.signer.in_memory_signer.InMemorySigner","text":"","title":"InMemorySigner"},{"location":"api_docs/signer/#flow_py_sdk.signer.in_memory_signer.InMemorySigner.__init__","text":"Source code in flow_py_sdk/signer/in_memory_signer.py def __init__ ( self , * , hash_algo : HashAlgo , sign_algo : SignAlgo , private_key_hex : str ) -> None : super () . __init__ () self . hash_algo = hash_algo self . key = ecdsa . SigningKey . from_string ( bytes . fromhex ( private_key_hex ), curve = sign_algo . get_signing_curve () ) self . verifier = InMemoryVerifier ( hash_algo = hash_algo , sign_algo = sign_algo , public_key_hex = self . key . get_verifying_key () . to_string () . hex (), )","title":"__init__()"},{"location":"api_docs/signer/#flow_py_sdk.signer.in_memory_signer.InMemorySigner.sign","text":"The sign method signs a message with a tag and returns the signature","title":"sign()"},{"location":"api_docs/signer/#flow_py_sdk.signer.in_memory_signer.InMemorySigner.sign--parameters","text":"message : bytes The message to sign. tag : str The tag to sign with.","title":"Parameters"},{"location":"api_docs/signer/#flow_py_sdk.signer.in_memory_signer.InMemorySigner.sign--returns","text":"bytes The signed message. Source code in flow_py_sdk/signer/in_memory_signer.py def sign ( self , message : bytes , tag : Optional [ bytes ] = None ) -> bytes : hash_ = self . _hash_message ( message , tag ) return self . key . sign_digest_deterministic ( hash_ )","title":"Returns"},{"location":"api_docs/signer/#flow_py_sdk.signer.in_memory_signer.InMemorySigner.verify","text":"The verify method signs a message with a tag and returns the signature","title":"verify()"},{"location":"api_docs/signer/#flow_py_sdk.signer.in_memory_signer.InMemorySigner.verify--parameters","text":"signature : bytes The signature to verify. message : bytes The message to verify. tag : str The tag to verify.","title":"Parameters"},{"location":"api_docs/signer/#flow_py_sdk.signer.in_memory_signer.InMemorySigner.verify--returns","text":"bool Is the signature valid. Source code in flow_py_sdk/signer/in_memory_signer.py def verify ( self , signature : bytes , message : bytes , tag : bytes ) -> bool : return self . verifier . verify ( signature , message , tag )","title":"Returns"}]}